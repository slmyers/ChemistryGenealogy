<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>web\bower_components\angular-material\modules\closure\core\core.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/editController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">editController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/GruntFile
                
                Was attempting to do gruntdocs....html">GruntFile
                
                Was attempting to do gruntdocs...</a></li>
                                <li><a href="../classes/mentorshipNotificationController
                
                Notifications for mentorships are dealt with here..html">mentorshipNotificationController
                
                Notifications for mentorships are dealt with here.</a></li>
                                <li><a href="../classes/muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application..html">muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file..html">personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file.</a></li>
                                <li><a href="../classes/personNotificationController
                
                Notifications for persons are dealt with here..html">personNotificationController
                
                Notifications for persons are dealt with here.</a></li>
                                <li><a href="../classes/searchController
                
                Entire Search Functionality located here..html">searchController
                
                Entire Search Functionality located here.</a></li>
                                <li><a href="../classes/submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc.html">submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc</a></li>
                                <li><a href="../classes/supervisionNotificationController
                
                Notifications for supervision are dealt with here..html">supervisionNotificationController
                
                Notifications for supervision are dealt with here.</a></li>
                                <li><a href="../classes/userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions..html">userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions.</a></li>
                                <li><a href="../classes/viewController
                
                This controller does all that can be done with the view page..html">viewController
                
                This controller does all that can be done with the view page.</a></li>
                                <li><a href="../classes/visController
                
                Notifications for mentorships are dealt with here..html">visController
                
                Notifications for mentorships are dealt with here.</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/auditTrailController.html">auditTrailController</a></li>
                                <li><a href="../modules/editController.html">editController</a></li>
                                <li><a href="../modules/GruntFile.html">GruntFile</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/mentorshipNotificationController.html">mentorshipNotificationController</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                                <li><a href="../modules/personNotificationController.html">personNotificationController</a></li>
                                <li><a href="../modules/searchController.html">searchController</a></li>
                                <li><a href="../modules/submitController.html">submitController</a></li>
                                <li><a href="../modules/supervisionNotificationController.html">supervisionNotificationController</a></li>
                                <li><a href="../modules/userController.html">userController</a></li>
                                <li><a href="../modules/userDialogController.html">userDialogController</a></li>
                                <li><a href="../modules/viewController.html">viewController</a></li>
                                <li><a href="../modules/visController.html">visController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: web\bower_components\angular-material\modules\closure\core\core.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.6
 */
goog.provide(&#x27;ng.material.core&#x27;);




goog.require(&#x27;ng.ngAnimate&#x27;);
/**
 * Initialization function that validates environment
 * requirements.
 */
angular
  .module(&#x27;material.core&#x27;, [
    &#x27;ngAnimate&#x27;,
    &#x27;material.core.animate&#x27;,
    &#x27;material.core.layout&#x27;,
    &#x27;material.core.gestures&#x27;,
    &#x27;material.core.theming&#x27;
  ])
  .config(MdCoreConfigure)
  .run(DetectNgTouch);


/**
 * Detect if the ng-Touch module is also being used.
 * Warn if detected.
 */
function DetectNgTouch($log, $injector) {
  if ( $injector.has(&#x27;$swipe&#x27;) ) {
    var msg = &quot;&quot; +
      &quot;You are using the ngTouch module. \n&quot; +
      &quot;Angular Material already has mobile click, tap, and swipe support... \n&quot; +
      &quot;ngTouch is not supported with Angular Material!&quot;;
    $log.warn(msg);
  }
}
DetectNgTouch.$inject = [&quot;$log&quot;, &quot;$injector&quot;];


function MdCoreConfigure($provide, $mdThemingProvider) {

  $provide.decorator(&#x27;$$rAF&#x27;, [&quot;$delegate&quot;, rAFDecorator]);

  $mdThemingProvider.theme(&#x27;default&#x27;)
    .primaryPalette(&#x27;indigo&#x27;)
    .accentPalette(&#x27;pink&#x27;)
    .warnPalette(&#x27;deep-orange&#x27;)
    .backgroundPalette(&#x27;grey&#x27;);
}
MdCoreConfigure.$inject = [&quot;$provide&quot;, &quot;$mdThemingProvider&quot;];

function rAFDecorator($delegate) {
  /**
   * Use this to throttle events that come in often.
   * The throttled function will always use the *last* invocation before the
   * coming frame.
   *
   * For example, window resize events that fire many times a second:
   * If we set to use an raf-throttled callback on window resize, then
   * our callback will only be fired once per frame, with the last resize
   * event that happened before that frame.
   *
   * @param {function} callback function to debounce
   */
  $delegate.throttle = function(cb) {
    var queuedArgs, alreadyQueued, queueCb, context;
    return function debounced() {
      queuedArgs = arguments;
      context = this;
      queueCb = cb;
      if (!alreadyQueued) {
        alreadyQueued = true;
        $delegate(function() {
          queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
          alreadyQueued = false;
        });
      }
    };
  };
  return $delegate;
}

angular.module(&#x27;material.core&#x27;)
  .directive(&#x27;mdAutofocus&#x27;, MdAutofocusDirective)

  // Support the deprecated md-auto-focus and md-sidenav-focus as well
  .directive(&#x27;mdAutoFocus&#x27;, MdAutofocusDirective)
  .directive(&#x27;mdSidenavFocus&#x27;, MdAutofocusDirective);

/**
 * @ngdoc directive
 * @name mdAutofocus
 * @module material.core.util
 *
 * @description
 *
 * &#x60;[md-autofocus]&#x60; provides an optional way to identify the focused element when a &#x60;$mdDialog&#x60;,
 * &#x60;$mdBottomSheet&#x60;, or &#x60;$mdSidenav&#x60; opens or upon page load for input-like elements.
 *
 * When one of these opens, it will find the first nested element with the &#x60;[md-autofocus]&#x60;
 * attribute directive and optional expression. An expression may be specified as the directive
 * value to enable conditional activation of the autofocus.
 *
 * @usage
 *
 * ### Dialog
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-dialog&gt;
 *   &lt;form&gt;
 *     &lt;md-input-container&gt;
 *       &lt;label for=&quot;testInput&quot;&gt;Label&lt;/label&gt;
 *       &lt;input id=&quot;testInput&quot; type=&quot;text&quot; md-autofocus&gt;
 *     &lt;/md-input-container&gt;
 *   &lt;/form&gt;
 * &lt;/md-dialog&gt;
 * &lt;/hljs&gt;
 *
 * ### Bottomsheet
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-bottom-sheet class=&quot;md-list md-has-header&quot;&gt;
 *  &lt;md-subheader&gt;Comment Actions&lt;/md-subheader&gt;
 *  &lt;md-list&gt;
 *    &lt;md-list-item ng-repeat=&quot;item in items&quot;&gt;
 *
 *      &lt;md-button md-autofocus=&quot;$index == 2&quot;&gt;
 *        &lt;md-icon md-svg-src=&quot;{{item.icon}}&quot;&gt;&lt;/md-icon&gt;
 *        &lt;span class=&quot;md-inline-list-icon-label&quot;&gt;{{ item.name }}&lt;/span&gt;
 *      &lt;/md-button&gt;
 *
 *    &lt;/md-list-item&gt;
 *  &lt;/md-list&gt;
 * &lt;/md-bottom-sheet&gt;
 * &lt;/hljs&gt;
 *
 * ### Autocomplete
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;md-autocomplete
 *       md-autofocus
 *       md-selected-item=&quot;selectedItem&quot;
 *       md-search-text=&quot;searchText&quot;
 *       md-items=&quot;item in getMatches(searchText)&quot;
 *       md-item-text=&quot;item.display&quot;&gt;
 *     &lt;span md-highlight-text=&quot;searchText&quot;&gt;{{item.display}}&lt;/span&gt;
 *   &lt;/md-autocomplete&gt;
 * &lt;/hljs&gt;
 *
 * ### Sidenav
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;div layout=&quot;row&quot; ng-controller=&quot;MyController&quot;&gt;
 *   &lt;md-sidenav md-component-id=&quot;left&quot; class=&quot;md-sidenav-left&quot;&gt;
 *     Left Nav!
 *   &lt;/md-sidenav&gt;
 *
 *   &lt;md-content&gt;
 *     Center Content
 *     &lt;md-button ng-click=&quot;openLeftMenu()&quot;&gt;
 *       Open Left Menu
 *     &lt;/md-button&gt;
 *   &lt;/md-content&gt;
 *
 *   &lt;md-sidenav md-component-id=&quot;right&quot;
 *     md-is-locked-open=&quot;$mdMedia(&#x27;min-width: 333px&#x27;)&quot;
 *     class=&quot;md-sidenav-right&quot;&gt;
 *     &lt;form&gt;
 *       &lt;md-input-container&gt;
 *         &lt;label for=&quot;testInput&quot;&gt;Test input&lt;/label&gt;
 *         &lt;input id=&quot;testInput&quot; type=&quot;text&quot;
 *                ng-model=&quot;data&quot; md-autofocus&gt;
 *       &lt;/md-input-container&gt;
 *     &lt;/form&gt;
 *   &lt;/md-sidenav&gt;
 * &lt;/div&gt;
 * &lt;/hljs&gt;
 **/
function MdAutofocusDirective() {
  return {
    restrict: &#x27;A&#x27;,

    link: postLink
  }
}

function postLink(scope, element, attrs) {
  var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;

  // Setup a watcher on the proper attribute to update a class we can check for in $mdUtil
  scope.$watch(attr, function(canAutofocus) {
    element.toggleClass(&#x27;_md-autofocus&#x27;, canAutofocus);
  });
}

angular.module(&#x27;material.core&#x27;)
.factory(&#x27;$mdConstant&#x27;, MdConstantFactory);

/**
 * Factory function that creates the grab-bag $mdConstant service.
 * ngInject
 */
function MdConstantFactory($sniffer) {

  var webkit = /webkit/i.test($sniffer.vendorPrefix);
  function vendorProperty(name) {
    return webkit ?  (&#x27;webkit&#x27; + name.charAt(0).toUpperCase() + name.substring(1)) : name;
  }

  return {
    KEY_CODE: {
      COMMA: 188,
      SEMICOLON : 186,
      ENTER: 13,
      ESCAPE: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW : 37,
      UP_ARROW : 38,
      RIGHT_ARROW : 39,
      DOWN_ARROW : 40,
      TAB : 9,
      BACKSPACE: 8,
      DELETE: 46
    },
    CSS: {
      /* Constants */
      TRANSITIONEND: &#x27;transitionend&#x27; + (webkit ? &#x27; webkitTransitionEnd&#x27; : &#x27;&#x27;),
      ANIMATIONEND: &#x27;animationend&#x27; + (webkit ? &#x27; webkitAnimationEnd&#x27; : &#x27;&#x27;),

      TRANSFORM: vendorProperty(&#x27;transform&#x27;),
      TRANSFORM_ORIGIN: vendorProperty(&#x27;transformOrigin&#x27;),
      TRANSITION: vendorProperty(&#x27;transition&#x27;),
      TRANSITION_DURATION: vendorProperty(&#x27;transitionDuration&#x27;),
      ANIMATION_PLAY_STATE: vendorProperty(&#x27;animationPlayState&#x27;),
      ANIMATION_DURATION: vendorProperty(&#x27;animationDuration&#x27;),
      ANIMATION_NAME: vendorProperty(&#x27;animationName&#x27;),
      ANIMATION_TIMING: vendorProperty(&#x27;animationTimingFunction&#x27;),
      ANIMATION_DIRECTION: vendorProperty(&#x27;animationDirection&#x27;)
    },
    /**
     * As defined in core/style/variables.scss
     *
     * $layout-breakpoint-xs:     600px !default;
     * $layout-breakpoint-sm:     960px !default;
     * $layout-breakpoint-md:     1280px !default;
     * $layout-breakpoint-lg:     1920px !default;
     *
     */
    MEDIA: {
      &#x27;xs&#x27;    : &#x27;(max-width: 599px)&#x27;                         ,
      &#x27;gt-xs&#x27; : &#x27;(min-width: 600px)&#x27;                         ,
      &#x27;sm&#x27;    : &#x27;(min-width: 600px) and (max-width: 959px)&#x27;  ,
      &#x27;gt-sm&#x27; : &#x27;(min-width: 960px)&#x27;                         ,
      &#x27;md&#x27;    : &#x27;(min-width: 960px) and (max-width: 1279px)&#x27; ,
      &#x27;gt-md&#x27; : &#x27;(min-width: 1280px)&#x27;                        ,
      &#x27;lg&#x27;    : &#x27;(min-width: 1280px) and (max-width: 1919px)&#x27;,
      &#x27;gt-lg&#x27; : &#x27;(min-width: 1920px)&#x27;                        ,
      &#x27;xl&#x27;    : &#x27;(min-width: 1920px)&#x27;                        ,
      &#x27;print&#x27; : &#x27;print&#x27;
    },
    MEDIA_PRIORITY: [
      &#x27;xl&#x27;,
      &#x27;gt-lg&#x27;,
      &#x27;lg&#x27;,
      &#x27;gt-md&#x27;,
      &#x27;md&#x27;,
      &#x27;gt-sm&#x27;,
      &#x27;sm&#x27;,
      &#x27;gt-xs&#x27;,
      &#x27;xs&#x27;,
      &#x27;print&#x27;
    ]
  };
}
MdConstantFactory.$inject = [&quot;$sniffer&quot;];

  angular
    .module(&#x27;material.core&#x27;)
    .config( [&quot;$provide&quot;, function($provide){
       $provide.decorator(&#x27;$mdUtil&#x27;, [&#x27;$delegate&#x27;, function ($delegate){
           /**
            * Inject the iterator facade to easily support iteration and accessors
            * @see iterator below
            */
           $delegate.iterator = MdIterator;

           return $delegate;
         }
       ]);
     }]);

  /**
   * iterator is a list facade to easily support iteration and accessors
   *
   * @param items Array list which this iterator will enumerate
   * @param reloop Boolean enables iterator to consider the list as an endless reloop
   */
  function MdIterator(items, reloop) {
    var trueFn = function() { return true; };

    if (items &amp;&amp; !angular.isArray(items)) {
      items = Array.prototype.slice.call(items);
    }

    reloop = !!reloop;
    var _items = items || [ ];

    // Published API
    return {
      items: getItems,
      count: count,

      inRange: inRange,
      contains: contains,
      indexOf: indexOf,
      itemAt: itemAt,

      findBy: findBy,

      add: add,
      remove: remove,

      first: first,
      last: last,
      next: angular.bind(null, findSubsequentItem, false),
      previous: angular.bind(null, findSubsequentItem, true),

      hasPrevious: hasPrevious,
      hasNext: hasNext

    };

    /**
     * Publish copy of the enumerable set
     * @returns {Array|*}
     */
    function getItems() {
      return [].concat(_items);
    }

    /**
     * Determine length of the list
     * @returns {Array.length|*|number}
     */
    function count() {
      return _items.length;
    }

    /**
     * Is the index specified valid
     * @param index
     * @returns {Array.length|*|number|boolean}
     */
    function inRange(index) {
      return _items.length &amp;&amp; ( index &gt; -1 ) &amp;&amp; (index &lt; _items.length );
    }

    /**
     * Can the iterator proceed to the next item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
    function hasNext(item) {
      return item ? inRange(indexOf(item) + 1) : false;
    }

    /**
     * Can the iterator proceed to the previous item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
    function hasPrevious(item) {
      return item ? inRange(indexOf(item) - 1) : false;
    }

    /**
     * Get item at specified index/position
     * @param index
     * @returns {*}
     */
    function itemAt(index) {
      return inRange(index) ? _items[index] : null;
    }

    /**
     * Find all elements matching the key/value pair
     * otherwise return null
     *
     * @param val
     * @param key
     *
     * @return array
     */
    function findBy(key, val) {
      return _items.filter(function(item) {
        return item[key] === val;
      });
    }

    /**
     * Add item to list
     * @param item
     * @param index
     * @returns {*}
     */
    function add(item, index) {
      if ( !item ) return -1;

      if (!angular.isNumber(index)) {
        index = _items.length;
      }

      _items.splice(index, 0, item);

      return indexOf(item);
    }

    /**
     * Remove item from list...
     * @param item
     */
    function remove(item) {
      if ( contains(item) ){
        _items.splice(indexOf(item), 1);
      }
    }

    /**
     * Get the zero-based index of the target item
     * @param item
     * @returns {*}
     */
    function indexOf(item) {
      return _items.indexOf(item);
    }

    /**
     * Boolean existence check
     * @param item
     * @returns {boolean}
     */
    function contains(item) {
      return item &amp;&amp; (indexOf(item) &gt; -1);
    }

    /**
     * Return first item in the list
     * @returns {*}
     */
    function first() {
      return _items.length ? _items[0] : null;
    }

    /**
     * Return last item in the list...
     * @returns {*}
     */
    function last() {
      return _items.length ? _items[_items.length - 1] : null;
    }

    /**
     * Find the next item. If reloop is true and at the end of the list, it will go back to the
     * first item. If given, the &#x60;validate&#x60; callback will be used to determine whether the next item
     * is valid. If not valid, it will try to find the next item again.
     *
     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)
     * @param {*} item The item whose subsequent item we are looking for
     * @param {Function=} validate The &#x60;validate&#x60; function
     * @param {integer=} limit The recursion limit
     *
     * @returns {*} The subsequent item or null
     */
    function findSubsequentItem(backwards, item, validate, limit) {
      validate = validate || trueFn;

      var curIndex = indexOf(item);
      while (true) {
        if (!inRange(curIndex)) return null;

        var nextIndex = curIndex + (backwards ? -1 : 1);
        var foundItem = null;
        if (inRange(nextIndex)) {
          foundItem = _items[nextIndex];
        } else if (reloop) {
          foundItem = backwards ? last() : first();
          nextIndex = indexOf(foundItem);
        }

        if ((foundItem === null) || (nextIndex === limit)) return null;
        if (validate(foundItem)) return foundItem;

        if (angular.isUndefined(limit)) limit = nextIndex;

        curIndex = nextIndex;
      }
    }
  }


angular.module(&#x27;material.core&#x27;)
.factory(&#x27;$mdMedia&#x27;, mdMediaFactory);

/**
 * @ngdoc service
 * @name $mdMedia
 * @module material.core
 *
 * @description
 * &#x60;$mdMedia&#x60; is used to evaluate whether a given media query is true or false given the
 * current device&#x27;s screen / window size. The media query will be re-evaluated on resize, allowing
 * you to register a watch.
 *
 * &#x60;$mdMedia&#x60; also has pre-programmed support for media queries that match the layout breakpoints:
 *
 *  &lt;table class=&quot;md-api-table&quot;&gt;
 *    &lt;thead&gt;
 *    &lt;tr&gt;
 *      &lt;th&gt;Breakpoint&lt;/th&gt;
 *      &lt;th&gt;mediaQuery&lt;/th&gt;
 *    &lt;/tr&gt;
 *    &lt;/thead&gt;
 *    &lt;tbody&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;xs&lt;/td&gt;
 *      &lt;td&gt;(max-width: 599px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;gt-xs&lt;/td&gt;
 *      &lt;td&gt;(min-width: 600px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;sm&lt;/td&gt;
 *      &lt;td&gt;(min-width: 600px) and (max-width: 959px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;gt-sm&lt;/td&gt;
 *      &lt;td&gt;(min-width: 960px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;md&lt;/td&gt;
 *      &lt;td&gt;(min-width: 960px) and (max-width: 1279px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;gt-md&lt;/td&gt;
 *      &lt;td&gt;(min-width: 1280px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;lg&lt;/td&gt;
 *      &lt;td&gt;(min-width: 1280px) and (max-width: 1919px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;gt-lg&lt;/td&gt;
 *      &lt;td&gt;(min-width: 1920px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;xl&lt;/td&gt;
 *      &lt;td&gt;(min-width: 1920px)&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *      &lt;td&gt;print&lt;/td&gt;
 *      &lt;td&gt;print&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;/tbody&gt;
 *  &lt;/table&gt;
 *
 *  See Material Design&#x27;s &lt;a href=&quot;https://www.google.com/design/spec/layout/adaptive-ui.html&quot;&gt;Layout - Adaptive UI&lt;/a&gt; for more details.
 *
 *  &lt;a href=&quot;https://www.google.com/design/spec/layout/adaptive-ui.html&quot;&gt;
 *  &lt;img src=&quot;https://material-design.storage.googleapis.com/publish/material_v_4/material_ext_publish/0B8olV15J7abPSGFxemFiQVRtb1k/layout_adaptive_breakpoints_01.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/img&gt;
 *  &lt;/a&gt;
 *
 * @returns {boolean} a boolean representing whether or not the given media query is true or false.
 *
 * @usage
 * &lt;hljs lang=&quot;js&quot;&gt;
 * app.controller(&#x27;MyController&#x27;, function($mdMedia, $scope) {
 *   $scope.$watch(function() { return $mdMedia(&#x27;lg&#x27;); }, function(big) {
 *     $scope.bigScreen = big;
 *   });
 *
 *   $scope.screenIsSmall = $mdMedia(&#x27;sm&#x27;);
 *   $scope.customQuery = $mdMedia(&#x27;(min-width: 1234px)&#x27;);
 *   $scope.anotherCustom = $mdMedia(&#x27;max-width: 300px&#x27;);
 * });
 * &lt;/hljs&gt;
 */

function mdMediaFactory($mdConstant, $rootScope, $window) {
  var queries = {};
  var mqls = {};
  var results = {};
  var normalizeCache = {};

  $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
  $mdMedia.getQuery = getQuery;
  $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;

  return $mdMedia;

  function $mdMedia(query) {
    var validated = queries[query];
    if (angular.isUndefined(validated)) {
      validated = queries[query] = validate(query);
    }

    var result = results[validated];
    if (angular.isUndefined(result)) {
      result = add(validated);
    }

    return result;
  }

  function validate(query) {
    return $mdConstant.MEDIA[query] ||
           ((query.charAt(0) !== &#x27;(&#x27;) ? (&#x27;(&#x27; + query + &#x27;)&#x27;) : query);
  }

  function add(query) {
    var result = mqls[query];
    if ( !result ) {
      result = mqls[query] = $window.matchMedia(query);
    }

    result.addListener(onQueryChange);
    return (results[result.media] = !!result.matches);
  }

  function onQueryChange(query) {
    $rootScope.$evalAsync(function() {
      results[query.media] = !!query.matches;
    });
  }

  function getQuery(name) {
    return mqls[name];
  }

  function getResponsiveAttribute(attrs, attrName) {
    for (var i = 0; i &lt; $mdConstant.MEDIA_PRIORITY.length; i++) {
      var mediaName = $mdConstant.MEDIA_PRIORITY[i];
      if (!mqls[queries[mediaName]].matches) {
        continue;
      }

      var normalizedName = getNormalizedName(attrs, attrName + &#x27;-&#x27; + mediaName);
      if (attrs[normalizedName]) {
        return attrs[normalizedName];
      }
    }

    // fallback on unprefixed
    return attrs[getNormalizedName(attrs, attrName)];
  }

  function watchResponsiveAttributes(attrNames, attrs, watchFn) {
    var unwatchFns = [];
    attrNames.forEach(function(attrName) {
      var normalizedName = getNormalizedName(attrs, attrName);
      if (angular.isDefined(attrs[normalizedName])) {
        unwatchFns.push(
            attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
      }

      for (var mediaName in $mdConstant.MEDIA) {
        normalizedName = getNormalizedName(attrs, attrName + &#x27;-&#x27; + mediaName);
        if (angular.isDefined(attrs[normalizedName])) {
          unwatchFns.push(
              attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
        }
      }
    });

    return function unwatch() {
      unwatchFns.forEach(function(fn) { fn(); })
    };
  }

  // Improves performance dramatically
  function getNormalizedName(attrs, attrName) {
    return normalizeCache[attrName] ||
        (normalizeCache[attrName] = attrs.$normalize(attrName));
  }
}
mdMediaFactory.$inject = [&quot;$mdConstant&quot;, &quot;$rootScope&quot;, &quot;$window&quot;];

/*
 * This var has to be outside the angular factory, otherwise when
 * there are multiple material apps on the same page, each app
 * will create its own instance of this array and the app&#x27;s IDs
 * will not be unique.
 */
var nextUniqueId = 0;

/**
 * @ngdoc module
 * @name material.core.util
 * @description
 * Util
 */
angular
  .module(&#x27;material.core&#x27;)
  .factory(&#x27;$mdUtil&#x27;, UtilFactory);

function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
  // Setup some core variables for the processTemplate method
  var startSymbol = $interpolate.startSymbol(),
    endSymbol = $interpolate.endSymbol(),
    usesStandardSymbols = ((startSymbol === &#x27;{{&#x27;) &amp;&amp; (endSymbol === &#x27;}}&#x27;));

  /**
   * Checks if the target element has the requested style by key
   * @param {DOMElement|JQLite} target Target element
   * @param {string} key Style key
   * @param {string=} expectedVal Optional expected value
   * @returns {boolean} Whether the target element has the style or not
   */
  var hasComputedStyle = function (target, key, expectedVal) {
    var hasValue = false;

    if ( target &amp;&amp; target.length  ) {
      var computedStyles = $window.getComputedStyle(target[0]);
      hasValue = angular.isDefined(computedStyles[key]) &amp;&amp; (expectedVal ? computedStyles[key] == expectedVal : true);
    }

    return hasValue;
  };

  var $mdUtil = {
    dom: {},
    now: window.performance ?
      angular.bind(window.performance, window.performance.now) : Date.now || function() {
      return new Date().getTime();
    },

    clientRect: function(element, offsetParent, isOffsetRect) {
      var node = getNode(element);
      offsetParent = getNode(offsetParent || node.offsetParent || document.body);
      var nodeRect = node.getBoundingClientRect();

      // The user can ask for an offsetRect: a rect relative to the offsetParent,
      // or a clientRect: a rect relative to the page
      var offsetRect = isOffsetRect ?
        offsetParent.getBoundingClientRect() :
      {left: 0, top: 0, width: 0, height: 0};
      return {
        left: nodeRect.left - offsetRect.left,
        top: nodeRect.top - offsetRect.top,
        width: nodeRect.width,
        height: nodeRect.height
      };
    },
    offsetRect: function(element, offsetParent) {
      return $mdUtil.clientRect(element, offsetParent, true);
    },

    // Annoying method to copy nodes to an array, thanks to IE
    nodesToArray: function(nodes) {
      nodes = nodes || [];

      var results = [];
      for (var i = 0; i &lt; nodes.length; ++i) {
        results.push(nodes.item(i));
      }
      return results;
    },

    /**
     * Calculate the positive scroll offset
     * TODO: Check with pinch-zoom in IE/Chrome;
     *       https://code.google.com/p/chromium/issues/detail?id=496285
     */
    scrollTop: function(element) {
      element = angular.element(element || $document[0].body);

      var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
      var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;

      // Calculate the positive scroll offset
      return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
    },

    /**
     * Finds the proper focus target by searching the DOM.
     *
     * @param containerEl
     * @param attributeVal
     * @returns {*}
     */
    findFocusTarget: function(containerEl, attributeVal) {
      var AUTO_FOCUS = &#x27;[md-autofocus]&#x27;;
      var elToFocus;

      elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);

      if ( !elToFocus &amp;&amp; attributeVal != AUTO_FOCUS) {
        // Scan for deprecated attribute
        elToFocus = scanForFocusable(containerEl, &#x27;[md-auto-focus]&#x27;);

        if ( !elToFocus ) {
          // Scan for fallback to &#x27;universal&#x27; API
          elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
        }
      }

      return elToFocus;

      /**
       * Can target and nested children for specified Selector (attribute)
       * whose value may be an expression that evaluates to True/False.
       */
      function scanForFocusable(target, selector) {
        var elFound, items = target[0].querySelectorAll(selector);

        // Find the last child element with the focus attribute
        if ( items &amp;&amp; items.length ){
          items.length &amp;&amp; angular.forEach(items, function(it) {
            it = angular.element(it);

            // Check the element for the _md-autofocus class to ensure any associated expression
            // evaluated to true.
            var isFocusable = it.hasClass(&#x27;_md-autofocus&#x27;);
            if (isFocusable) elFound = it;
          });
        }
        return elFound;
      }
    },

    // Disables scroll around the passed element.
    disableScrollAround: function(element, parent) {
      $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
      ++$mdUtil.disableScrollAround._count;
      if ($mdUtil.disableScrollAround._enableScrolling) return $mdUtil.disableScrollAround._enableScrolling;
      element = angular.element(element);
      var body = $document[0].body,
        restoreBody = disableBodyScroll(),
        restoreElement = disableElementScroll(parent);

      return $mdUtil.disableScrollAround._enableScrolling = function() {
        if (!--$mdUtil.disableScrollAround._count) {
          restoreBody();
          restoreElement();
          delete $mdUtil.disableScrollAround._enableScrolling;
        }
      };

      // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events
      function disableElementScroll(element) {
        element = angular.element(element || body)[0];
        var zIndex = 50;
        var scrollMask = angular.element(
          &#x27;&lt;div class=&quot;md-scroll-mask&quot;&gt;&#x27; +
          &#x27;  &lt;div class=&quot;md-scroll-mask-bar&quot;&gt;&lt;/div&gt;&#x27; +
          &#x27;&lt;/div&gt;&#x27;).css(&#x27;z-index&#x27;, zIndex);
        element.appendChild(scrollMask[0]);

        scrollMask.on(&#x27;wheel&#x27;, preventDefault);
        scrollMask.on(&#x27;touchmove&#x27;, preventDefault);
        $document.on(&#x27;keydown&#x27;, disableKeyNav);

        return function restoreScroll() {
          scrollMask.off(&#x27;wheel&#x27;);
          scrollMask.off(&#x27;touchmove&#x27;);
          scrollMask[0].parentNode.removeChild(scrollMask[0]);
          $document.off(&#x27;keydown&#x27;, disableKeyNav);
          delete $mdUtil.disableScrollAround._enableScrolling;
        };

        // Prevent keypresses from elements inside the body
        // used to stop the keypresses that could cause the page to scroll
        // (arrow keys, spacebar, tab, etc).
        function disableKeyNav(e) {
          //-- temporarily removed this logic, will possibly re-add at a later date
          //if (!element[0].contains(e.target)) {
          //  e.preventDefault();
          //  e.stopImmediatePropagation();
          //}
        }

        function preventDefault(e) {
          e.preventDefault();
        }
      }

      // Converts the body to a position fixed block and translate it to the proper scroll
      // position
      function disableBodyScroll() {
        var htmlNode = body.parentNode;
        var restoreHtmlStyle = htmlNode.style.cssText || &#x27;&#x27;;
        var restoreBodyStyle = body.style.cssText || &#x27;&#x27;;
        var scrollOffset = $mdUtil.scrollTop(body);
        var clientWidth = body.clientWidth;

        if (body.scrollHeight &gt; body.clientHeight + 1) {
          applyStyles(body, {
            position: &#x27;fixed&#x27;,
            width: &#x27;100%&#x27;,
            top: -scrollOffset + &#x27;px&#x27;
          });

          applyStyles(htmlNode, {
            overflowY: &#x27;scroll&#x27;
          });
        }

        if (body.clientWidth &lt; clientWidth) applyStyles(body, {overflow: &#x27;hidden&#x27;});

        return function restoreScroll() {
          body.style.cssText = restoreBodyStyle;
          htmlNode.style.cssText = restoreHtmlStyle;
          body.scrollTop = scrollOffset;
          htmlNode.scrollTop = scrollOffset;
        };
      }

      function applyStyles(el, styles) {
        for (var key in styles) {
          el.style[key] = styles[key];
        }
      }
    },
    enableScrolling: function() {
      var method = this.disableScrollAround._enableScrolling;
      method &amp;&amp; method();
    },
    floatingScrollbars: function() {
      if (this.floatingScrollbars.cached === undefined) {
        var tempNode = angular.element(&#x27;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;).css({
          width: &#x27;100%&#x27;,
          &#x27;z-index&#x27;: -1,
          position: &#x27;absolute&#x27;,
          height: &#x27;35px&#x27;,
          &#x27;overflow-y&#x27;: &#x27;scroll&#x27;
        });
        tempNode.children().css(&#x27;height&#x27;, &#x27;60px&#x27;);

        $document[0].body.appendChild(tempNode[0]);
        this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
        tempNode.remove();
      }
      return this.floatingScrollbars.cached;
    },

    // Mobile safari only allows you to set focus in click event listeners...
    forceFocus: function(element) {
      var node = element[0] || element;

      document.addEventListener(&#x27;click&#x27;, function focusOnClick(ev) {
        if (ev.target === node &amp;&amp; ev.$focus) {
          node.focus();
          ev.stopImmediatePropagation();
          ev.preventDefault();
          node.removeEventListener(&#x27;click&#x27;, focusOnClick);
        }
      }, true);

      var newEvent = document.createEvent(&#x27;MouseEvents&#x27;);
      newEvent.initMouseEvent(&#x27;click&#x27;, false, true, window, {}, 0, 0, 0, 0,
        false, false, false, false, 0, null);
      newEvent.$material = true;
      newEvent.$focus = true;
      node.dispatchEvent(newEvent);
    },

    /**
     * facade to build md-backdrop element with desired styles
     * NOTE: Use $compile to trigger backdrop postLink function
     */
    createBackdrop: function(scope, addClass) {
      return $compile($mdUtil.supplant(&#x27;&lt;md-backdrop class=&quot;{0}&quot;&gt;&#x27;, [addClass]))(scope);
    },

    /**
     * supplant() method from Crockford&#x27;s &#x60;Remedial Javascript&#x60;
     * Equivalent to use of $interpolate; without dependency on
     * interpolation symbols and scope. Note: the &#x27;{&lt;token&gt;}&#x27; can
     * be property names, property chains, or array indices.
     */
    supplant: function(template, values, pattern) {
      pattern = pattern || /\{([^\{\}]*)\}/g;
      return template.replace(pattern, function(a, b) {
        var p = b.split(&#x27;.&#x27;),
          r = values;
        try {
          for (var s in p) {
            if (p.hasOwnProperty(s) ) {
              r = r[p[s]];
            }
          }
        } catch (e) {
          r = a;
        }
        return (typeof r === &#x27;string&#x27; || typeof r === &#x27;number&#x27;) ? r : a;
      });
    },

    fakeNgModel: function() {
      return {
        $fake: true,
        $setTouched: angular.noop,
        $setViewValue: function(value) {
          this.$viewValue = value;
          this.$render(value);
          this.$viewChangeListeners.forEach(function(cb) {
            cb();
          });
        },
        $isEmpty: function(value) {
          return (&#x27;&#x27; + value).length === 0;
        },
        $parsers: [],
        $formatters: [],
        $viewChangeListeners: [],
        $render: angular.noop
      };
    },

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds.
    // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs
    // @param invokeApply should the $timeout trigger $digest() dirty checking
    debounce: function(func, wait, scope, invokeApply) {
      var timer;

      return function debounced() {
        var context = scope,
          args = Array.prototype.slice.call(arguments);

        $timeout.cancel(timer);
        timer = $timeout(function() {

          timer = undefined;
          func.apply(context, args);

        }, wait || 10, invokeApply);
      };
    },

    // Returns a function that can only be triggered every &#x60;delay&#x60; milliseconds.
    // In other words, the function will not be called unless it has been more
    // than &#x60;delay&#x60; milliseconds since the last call.
    throttle: function throttle(func, delay) {
      var recent;
      return function throttled() {
        var context = this;
        var args = arguments;
        var now = $mdUtil.now();

        if (!recent || (now - recent &gt; delay)) {
          func.apply(context, args);
          recent = now;
        }
      };
    },

    /**
     * Measures the number of milliseconds taken to run the provided callback
     * function. Uses a high-precision timer if available.
     */
    time: function time(cb) {
      var start = $mdUtil.now();
      cb();
      return $mdUtil.now() - start;
    },

    /**
     * Create an implicit getter that caches its &#x60;getter()&#x60;
     * lookup value
     */
    valueOnUse : function (scope, key, getter) {
      var value = null, args = Array.prototype.slice.call(arguments);
      var params = (args.length &gt; 3) ? args.slice(3) : [ ];

      Object.defineProperty(scope, key, {
        get: function () {
          if (value === null) value = getter.apply(scope, params);
          return value;
        }
      });
    },

    /**
     * Get a unique ID.
     *
     * @returns {string} an unique numeric string
     */
    nextUid: function() {
      return &#x27;&#x27; + nextUniqueId++;
    },

    // Stop watchers and events from firing on a scope without destroying it,
    // by disconnecting it from its parent and its siblings&#x27; linked lists.
    disconnectScope: function disconnectScope(scope) {
      if (!scope) return;

      // we can&#x27;t destroy the root scope or a scope that has been already destroyed
      if (scope.$root === scope) return;
      if (scope.$$destroyed) return;

      var parent = scope.$parent;
      scope.$$disconnected = true;

      // See Scope.$destroy
      if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;
      if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;
      if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
      if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;

      scope.$$nextSibling = scope.$$prevSibling = null;

    },

    // Undo the effects of disconnectScope above.
    reconnectScope: function reconnectScope(scope) {
      if (!scope) return;

      // we can&#x27;t disconnect the root node or scope already disconnected
      if (scope.$root === scope) return;
      if (!scope.$$disconnected) return;

      var child = scope;

      var parent = child.$parent;
      child.$$disconnected = false;
      // See Scope.$new for this logic...
      child.$$prevSibling = parent.$$childTail;
      if (parent.$$childHead) {
        parent.$$childTail.$$nextSibling = child;
        parent.$$childTail = child;
      } else {
        parent.$$childHead = parent.$$childTail = child;
      }
    },

    /*
     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName
     *
     * @param el Element to start walking the DOM from
     * @param tagName Tag name to find closest to el, such as &#x27;form&#x27;
     * @param onlyParent Only start checking from the parent element, not &#x60;el&#x60;.
     */
    getClosest: function getClosest(el, tagName, onlyParent) {
      if (el instanceof angular.element) el = el[0];
      tagName = tagName.toUpperCase();
      if (onlyParent) el = el.parentNode;
      if (!el) return null;
      do {
        if (el.nodeName === tagName) {
          return el;
        }
      } while (el = el.parentNode);
      return null;
    },

    /**
     * Build polyfill for the Node.contains feature (if needed)
     */
    elementContains: function(node, child) {
      var hasContains = (window.Node &amp;&amp; window.Node.prototype &amp;&amp; Node.prototype.contains);
      var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
        // compares the positions of two nodes and returns a bitmask
        return (node === child) || !!(this.compareDocumentPosition(arg) &amp; 16)
      });

      return findFn(child);
    },

    /**
     * Functional equivalent for $element.filter(md-bottom-sheet)
     * useful with interimElements where the element and its container are important...
     *
     * @param {[]} elements to scan
     * @param {string} name of node to find (e.g. &#x27;md-dialog&#x27;)
     * @param {boolean=} optional flag to allow deep scans; defaults to &#x27;false&#x27;.
     * @param {boolean=} optional flag to enable log warnings; defaults to false
     */
    extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
      var found = scanTree(element);
      if (!found &amp;&amp; !!warnNotFound) {
        $log.warn( $mdUtil.supplant(&quot;Unable to find node &#x27;{0}&#x27; in element &#x27;{1}&#x27;.&quot;,[nodeName, element[0].outerHTML]) );
      }

      return angular.element(found || element);

      /**
       * Breadth-First tree scan for element with matching &#x60;nodeName&#x60;
       */
      function scanTree(element) {
        return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
      }

      /**
       * Case-insensitive scan of current elements only (do not descend).
       */
      function scanLevel(element) {
        if ( element ) {
          for (var i = 0, len = element.length; i &lt; len; i++) {
            if (element[i].nodeName.toLowerCase() === nodeName) {
              return element[i];
            }
          }
        }
        return null;
      }

      /**
       * Scan children of specified node
       */
      function scanChildren(element) {
        var found;
        if ( element ) {
          for (var i = 0, len = element.length; i &lt; len; i++) {
            var target = element[i];
            if ( !found ) {
              for (var j = 0, numChild = target.childNodes.length; j &lt; numChild; j++) {
                found = found || scanTree([target.childNodes[j]]);
              }
            }
          }
        }
        return found;
      }

    },

    /**
     * Give optional properties with no value a boolean true if attr provided or false otherwise
     */
    initOptionalProperties: function(scope, attr, defaults) {
      defaults = defaults || {};
      angular.forEach(scope.$$isolateBindings, function(binding, key) {
        if (binding.optional &amp;&amp; angular.isUndefined(scope[key])) {
          var attrIsDefined = angular.isDefined(attr[binding.attrName]);
          scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
        }
      });
    },

    /**
     * Alternative to $timeout calls with 0 delay.
     * nextTick() coalesces all calls within a single frame
     * to minimize $digest thrashing
     *
     * @param callback
     * @param digest
     * @returns {*}
     */
    nextTick: function(callback, digest, scope) {
      //-- grab function reference for storing state details
      var nextTick = $mdUtil.nextTick;
      var timeout = nextTick.timeout;
      var queue = nextTick.queue || [];

      //-- add callback to the queue
      queue.push(callback);

      //-- set default value for digest
      if (digest == null) digest = true;

      //-- store updated digest/queue values
      nextTick.digest = nextTick.digest || digest;
      nextTick.queue = queue;

      //-- either return existing timeout or create a new one
      return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));

      /**
       * Grab a copy of the current queue
       * Clear the queue for future use
       * Process the existing queue
       * Trigger digest if necessary
       */
      function processQueue() {
        var skip = scope &amp;&amp; scope.$$destroyed;
        var queue = !skip ? nextTick.queue : [];
        var digest = !skip ? nextTick.digest : null;

        nextTick.queue = [];
        nextTick.timeout = null;
        nextTick.digest = false;

        queue.forEach(function(callback) {
          callback();
        });

        if (digest) $rootScope.$digest();
      }
    },

    /**
     * Processes a template and replaces the start/end symbols if the application has
     * overriden them.
     *
     * @param template The template to process whose start/end tags may be replaced.
     * @returns {*}
     */
    processTemplate: function(template) {
      if (usesStandardSymbols) {
        return template;
      } else {
        if (!template || !angular.isString(template)) return template;
        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
      }
    },

    /**
     * Scan up dom hierarchy for enabled parent;
     */
    getParentWithPointerEvents: function (element) {
      var parent = element.parent();

      // jqLite might return a non-null, but still empty, parent; so check for parent and length
      while (hasComputedStyle(parent, &#x27;pointer-events&#x27;, &#x27;none&#x27;)) {
        parent = parent.parent();
      }

      return parent;
    },

    getNearestContentElement: function (element) {
      var current = element.parent()[0];
      // Look for the nearest parent md-content, stopping at the rootElement.
      while (current &amp;&amp; current !== $rootElement[0] &amp;&amp; current !== document.body &amp;&amp; current.nodeName.toUpperCase() !== &#x27;MD-CONTENT&#x27;) {
        current = current.parentNode;
      }
      return current;
    },

    hasComputedStyle: hasComputedStyle
  };

// Instantiate other namespace utility methods

  $mdUtil.dom.animator = $$mdAnimate($mdUtil);

  return $mdUtil;

  function getNode(el) {
    return el[0] || el;
  }

}
UtilFactory.$inject = [&quot;$document&quot;, &quot;$timeout&quot;, &quot;$compile&quot;, &quot;$rootScope&quot;, &quot;$$mdAnimate&quot;, &quot;$interpolate&quot;, &quot;$log&quot;, &quot;$rootElement&quot;, &quot;$window&quot;];

/*
 * Since removing jQuery from the demos, some code that uses &#x60;element.focus()&#x60; is broken.
 * We need to add &#x60;element.focus()&#x60;, because it&#x27;s testable unlike &#x60;element[0].focus&#x60;.
 */

angular.element.prototype.focus = angular.element.prototype.focus || function() {
    if (this.length) {
      this[0].focus();
    }
    return this;
  };
angular.element.prototype.blur = angular.element.prototype.blur || function() {
    if (this.length) {
      this[0].blur();
    }
    return this;
  };



angular.module(&#x27;material.core&#x27;)
  .service(&#x27;$mdAria&#x27;, AriaService);

/*
 * ngInject
 */
function AriaService($$rAF, $log, $window, $interpolate) {

  return {
    expect: expect,
    expectAsync: expectAsync,
    expectWithText: expectWithText
  };

  /**
   * Check if expected attribute has been specified on the target element or child
   * @param element
   * @param attrName
   * @param {optional} defaultValue What to set the attr to if no value is found
   */
  function expect(element, attrName, defaultValue) {

    var node = angular.element(element)[0] || element;

    // if node exists and neither it nor its children have the attribute
    if (node &amp;&amp;
       ((!node.hasAttribute(attrName) ||
        node.getAttribute(attrName).length === 0) &amp;&amp;
        !childHasAttribute(node, attrName))) {

      defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : &#x27;&#x27;;
      if (defaultValue.length) {
        element.attr(attrName, defaultValue);
      } else {
        $log.warn(&#x27;ARIA: Attribute &quot;&#x27;, attrName, &#x27;&quot;, required for accessibility, is missing on node:&#x27;, node);
      }

    }
  }

  function expectAsync(element, attrName, defaultValueGetter) {
    // Problem: when retrieving the element&#x27;s contents synchronously to find the label,
    // the text may not be defined yet in the case of a binding.
    // There is a higher chance that a binding will be defined if we wait one frame.
    $$rAF(function() {
        expect(element, attrName, defaultValueGetter());
    });
  }

  function expectWithText(element, attrName) {
    var content = getText(element) || &quot;&quot;;
    var hasBinding = content.indexOf($interpolate.startSymbol())&gt;-1;

    if ( hasBinding ) {
      expectAsync(element, attrName, function() {
        return getText(element);
      });
    } else {
      expect(element, attrName, content);
    }
  }

  function getText(element) {
    return (element.text() || &quot;&quot;).trim();
  }

  function childHasAttribute(node, attrName) {
    var hasChildren = node.hasChildNodes(),
        hasAttr = false;

    function isHidden(el) {
      var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
      return (style.display === &#x27;none&#x27;);
    }

    if(hasChildren) {
      var children = node.childNodes;
      for(var i=0; i&lt;children.length; i++){
        var child = children[i];
        if(child.nodeType === 1 &amp;&amp; child.hasAttribute(attrName)) {
          if(!isHidden(child)){
            hasAttr = true;
          }
        }
      }
    }
    return hasAttr;
  }
}
AriaService.$inject = [&quot;$$rAF&quot;, &quot;$log&quot;, &quot;$window&quot;, &quot;$interpolate&quot;];

angular
  .module(&#x27;material.core&#x27;)
  .service(&#x27;$mdCompiler&#x27;, mdCompilerService);

function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
  /* jshint validthis: true */

  /*
   * @ngdoc service
   * @name $mdCompiler
   * @module material.core
   * @description
   * The $mdCompiler service is an abstraction of angular&#x27;s compiler, that allows the developer
   * to easily compile an element with a templateUrl, controller, and locals.
   *
   * @usage
   * &lt;hljs lang=&quot;js&quot;&gt;
   * $mdCompiler.compile({
   *   templateUrl: &#x27;modal.html&#x27;,
   *   controller: &#x27;ModalCtrl&#x27;,
   *   locals: {
   *     modal: myModalInstance;
   *   }
   * }).then(function(compileData) {
   *   compileData.element; // modal.html&#x27;s template in an element
   *   compileData.link(myScope); //attach controller &amp; scope to element
   * });
   * &lt;/hljs&gt;
   */

   /*
    * @ngdoc method
    * @name $mdCompiler#compile
    * @description A helper to compile an HTML template/templateUrl with a given controller,
    * locals, and scope.
    * @param {object} options An options object, with the following properties:
    *
    *    - &#x60;controller&#x60; - &#x60;{(string=|function()=}&#x60; Controller fn that should be associated with
    *      newly created scope or the name of a registered controller if passed as a string.
    *    - &#x60;controllerAs&#x60; - &#x60;{string=}&#x60; A controller alias name. If present the controller will be
    *      published to scope under the &#x60;controllerAs&#x60; name.
    *    - &#x60;template&#x60; - &#x60;{string=}&#x60; An html template as a string.
    *    - &#x60;templateUrl&#x60; - &#x60;{string=}&#x60; A path to an html template.
    *    - &#x60;transformTemplate&#x60; - &#x60;{function(template)=}&#x60; A function which transforms the template after
    *      it is loaded. It will be given the template string as a parameter, and should
    *      return a a new string representing the transformed template.
    *    - &#x60;resolve&#x60; - &#x60;{Object.&lt;string, function&gt;=}&#x60; - An optional map of dependencies which should
    *      be injected into the controller. If any of these dependencies are promises, the compiler
    *      will wait for them all to be resolved, or if one is rejected before the controller is
    *      instantiated &#x60;compile()&#x60; will fail..
    *      * &#x60;key&#x60; - &#x60;{string}&#x60;: a name of a dependency to be injected into the controller.
    *      * &#x60;factory&#x60; - &#x60;{string|function}&#x60;: If &#x60;string&#x60; then it is an alias for a service.
    *        Otherwise if function, then it is injected and the return value is treated as the
    *        dependency. If the result is a promise, it is resolved before its value is
    *        injected into the controller.
    *
    * @returns {object=} promise A promise, which will be resolved with a &#x60;compileData&#x60; object.
    * &#x60;compileData&#x60; has the following properties:
    *
    *   - &#x60;element&#x60; - &#x60;{element}&#x60;: an uncompiled element matching the provided template.
    *   - &#x60;link&#x60; - &#x60;{function(scope)}&#x60;: A link function, which, when called, will compile
    *     the element and instantiate the provided controller (if given).
    *   - &#x60;locals&#x60; - &#x60;{object}&#x60;: The locals which will be passed into the controller once &#x60;link&#x60; is
    *     called. If &#x60;bindToController&#x60; is true, they will be coppied to the ctrl instead
    *   - &#x60;bindToController&#x60; - &#x60;bool&#x60;: bind the locals to the controller, instead of passing them in.
    */
  this.compile = function(options) {
    var templateUrl = options.templateUrl;
    var template = options.template || &#x27;&#x27;;
    var controller = options.controller;
    var controllerAs = options.controllerAs;
    var resolve = angular.extend({}, options.resolve || {});
    var locals = angular.extend({}, options.locals || {});
    var transformTemplate = options.transformTemplate || angular.identity;
    var bindToController = options.bindToController;

    // Take resolve values and invoke them.
    // Resolves can either be a string (value: &#x27;MyRegisteredAngularConst&#x27;),
    // or an invokable &#x27;factory&#x27; of sorts: (value: function ValueGetter($dependency) {})
    angular.forEach(resolve, function(value, key) {
      if (angular.isString(value)) {
        resolve[key] = $injector.get(value);
      } else {
        resolve[key] = $injector.invoke(value);
      }
    });
    //Add the locals, which are just straight values to inject
    //eg locals: { three: 3 }, will inject three into the controller
    angular.extend(resolve, locals);

    if (templateUrl) {
      resolve.$template = $http.get(templateUrl, {cache: $templateCache})
        .then(function(response) {
          return response.data;
        });
    } else {
      resolve.$template = $q.when(template);
    }

    // Wait for all the resolves to finish if they are promises
    return $q.all(resolve).then(function(locals) {

      var compiledData;
      var template = transformTemplate(locals.$template, options);
      var element = options.element || angular.element(&#x27;&lt;div&gt;&#x27;).html(template.trim()).contents();
      var linkFn = $compile(element);

      // Return a linking function that can be used later when the element is ready
      return compiledData = {
        locals: locals,
        element: element,
        link: function link(scope) {
          locals.$scope = scope;

          //Instantiate controller if it exists, because we have scope
          if (controller) {
            var invokeCtrl = $controller(controller, locals, true);
            if (bindToController) {
              angular.extend(invokeCtrl.instance, locals);
            }
            var ctrl = invokeCtrl();
            //See angular-route source for this logic
            element.data(&#x27;$ngControllerController&#x27;, ctrl);
            element.children().data(&#x27;$ngControllerController&#x27;, ctrl);

            if (controllerAs) {
              scope[controllerAs] = ctrl;
            }

            // Publish reference to this controller
            compiledData.controller = ctrl;
          }
          return linkFn(scope);
        }
      };
    });

  };
}
mdCompilerService.$inject = [&quot;$q&quot;, &quot;$http&quot;, &quot;$injector&quot;, &quot;$compile&quot;, &quot;$controller&quot;, &quot;$templateCache&quot;];

var HANDLERS = {};

/* The state of the current &#x27;pointer&#x27;
 * The pointer represents the state of the current touch.
 * It contains normalized x and y coordinates from DOM events,
 * as well as other information abstracted from the DOM.
 */
 
var pointer, lastPointer, forceSkipClickHijack = false;

/**
 * The position of the most recent click if that click was on a label element.
 * @type {{x: number, y: number}?}
 */
var lastLabelClickPos = null;

// Used to attach event listeners once when multiple ng-apps are running.
var isInitialized = false;

angular
  .module(&#x27;material.core.gestures&#x27;, [ ])
  .provider(&#x27;$mdGesture&#x27;, MdGestureProvider)
  .factory(&#x27;$$MdGestureHandler&#x27;, MdGestureHandler)
  .run( attachToDocument );

/**
   * @ngdoc service
   * @name $mdGestureProvider
   * @module material.core.gestures
   *
   * @description
   * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.
   * &#x60;$mdGestureProvider&#x60; is used to configure the Gesture module to ignore or skip click hijacking on mobile
   * devices.
   *
   * &lt;hljs lang=&quot;js&quot;&gt;
   *   app.config(function($mdGestureProvider) {
   *
   *     // For mobile devices without jQuery loaded, do not
   *     // intercept click events during the capture phase.
   *     $mdGestureProvider.skipClickHijack();
   *
   *   });
   * &lt;/hljs&gt;
   *
   */
function MdGestureProvider() { }

MdGestureProvider.prototype = {

  // Publish access to setter to configure a variable  BEFORE the
  // $mdGesture service is instantiated...
  skipClickHijack: function() {
    return forceSkipClickHijack = true;
  },

  /**
   * $get is used to build an instance of $mdGesture
   * ngInject
   */
  $get : [&quot;$$MdGestureHandler&quot;, &quot;$$rAF&quot;, &quot;$timeout&quot;, function($$MdGestureHandler, $$rAF, $timeout) {
       return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
  }]
};



/**
 * MdGesture factory construction function
 * ngInject
 */
function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  var isIos = userAgent.match(/ipad|iphone|ipod/i);
  var isAndroid = userAgent.match(/android/i);
  var hasJQuery =  (typeof window.jQuery !== &#x27;undefined&#x27;) &amp;&amp; (angular.element === window.jQuery);

  var self = {
    handler: addHandler,
    register: register,
    // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?
    isHijackingClicks: (isIos || isAndroid) &amp;&amp; !hasJQuery &amp;&amp; !forceSkipClickHijack
  };

  if (self.isHijackingClicks) {
    var maxClickDistance = 6;
    self.handler(&#x27;click&#x27;, {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: checkDistanceAndEmit(&#x27;click&#x27;)
    });

    self.handler(&#x27;focus&#x27;, {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: function(ev, pointer) {
        if (pointer.distance &lt; this.state.options.maxDistance) {
          if (canFocus(ev.target)) {
            this.dispatchEvent(ev, &#x27;focus&#x27;, pointer);
            ev.target.focus();
          }
        }

        function canFocus(element) {
          var focusableElements = [&#x27;INPUT&#x27;, &#x27;SELECT&#x27;, &#x27;BUTTON&#x27;, &#x27;TEXTAREA&#x27;, &#x27;VIDEO&#x27;, &#x27;AUDIO&#x27;];

          return (element.getAttribute(&#x27;tabindex&#x27;) != &#x27;-1&#x27;) &amp;&amp;
              !element.hasAttribute(&#x27;DISABLED&#x27;) &amp;&amp;
              (element.hasAttribute(&#x27;tabindex&#x27;) || element.hasAttribute(&#x27;href&#x27;) ||
              (focusableElements.indexOf(element.nodeName) != -1));
        }
      }
    });

    self.handler(&#x27;mouseup&#x27;, {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: checkDistanceAndEmit(&#x27;mouseup&#x27;)
    });

    self.handler(&#x27;mousedown&#x27;, {
      onStart: function(ev) {
        this.dispatchEvent(ev, &#x27;mousedown&#x27;);
      }
    });
  }

  function checkDistanceAndEmit(eventName) {
    return function(ev, pointer) {
      if (pointer.distance &lt; this.state.options.maxDistance) {
        this.dispatchEvent(ev, eventName, pointer);
      }
    };
  }

  /*
   * Register an element to listen for a handler.
   * This allows an element to override the default options for a handler.
   * Additionally, some handlers like drag and hold only dispatch events if
   * the domEvent happens inside an element that&#x27;s registered to listen for these events.
   *
   * @see GestureHandler for how overriding of default options works.
   * @example $mdGesture.register(myElement, &#x27;drag&#x27;, { minDistance: 20, horziontal: false })
   */
  function register(element, handlerName, options) {
    var handler = HANDLERS[handlerName.replace(/^\$md./, &#x27;&#x27;)];
    if (!handler) {
      throw new Error(&#x27;Failed to register element with handler &#x27; + handlerName + &#x27;. &#x27; +
      &#x27;Available handlers: &#x27; + Object.keys(HANDLERS).join(&#x27;, &#x27;));
    }
    return handler.registerElement(element, options);
  }

  /*
   * add a handler to $mdGesture. see below.
   */
  function addHandler(name, definition) {
    var handler = new $$MdGestureHandler(name);
    angular.extend(handler, definition);
    HANDLERS[name] = handler;

    return self;
  }

  /*
   * Register handlers. These listen to touch/start/move events, interpret them,
   * and dispatch gesture events depending on options &amp; conditions. These are all
   * instances of GestureHandler.
   * @see GestureHandler 
   */
  return self
    /*
     * The press handler dispatches an event on touchdown/touchend.
     * It&#x27;s a simple abstraction of touch/mouse/pointer start and end.
     */
    .handler(&#x27;press&#x27;, {
      onStart: function (ev, pointer) {
        this.dispatchEvent(ev, &#x27;$md.pressdown&#x27;);
      },
      onEnd: function (ev, pointer) {
        this.dispatchEvent(ev, &#x27;$md.pressup&#x27;);
      }
    })

    /*
     * The hold handler dispatches an event if the user keeps their finger within
     * the same &lt;maxDistance&gt; area for &lt;delay&gt; ms.
     * The hold handler will only run if a parent of the touch target is registered
     * to listen for hold events through $mdGesture.register()
     */
    .handler(&#x27;hold&#x27;, {
      options: {
        maxDistance: 6,
        delay: 500
      },
      onCancel: function () {
        $timeout.cancel(this.state.timeout);
      },
      onStart: function (ev, pointer) {
        // For hold, require a parent to be registered with $mdGesture.register()
        // Because we prevent scroll events, this is necessary.
        if (!this.state.registeredParent) return this.cancel();

        this.state.pos = {x: pointer.x, y: pointer.y};
        this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
          this.dispatchEvent(ev, &#x27;$md.hold&#x27;);
          this.cancel(); //we&#x27;re done!
        }), this.state.options.delay, false);
      },
      onMove: function (ev, pointer) {
        // Don&#x27;t scroll while waiting for hold.
        // If we don&#x27;t preventDefault touchmove events here, Android will assume we don&#x27;t
        // want to listen to anymore touch events. It will start scrolling and stop sending
        // touchmove events.
        ev.preventDefault();

        // If the user moves greater than &lt;maxDistance&gt; pixels, stop the hold timer
        // set in onStart
        var dx = this.state.pos.x - pointer.x;
        var dy = this.state.pos.y - pointer.y;
        if (Math.sqrt(dx * dx + dy * dy) &gt; this.options.maxDistance) {
          this.cancel();
        }
      },
      onEnd: function () {
        this.onCancel();
      }
    })

    /*
     * The drag handler dispatches a drag event if the user holds and moves his finger greater than
     * &lt;minDistance&gt; px in the x or y direction, depending on options.horizontal.
     * The drag will be cancelled if the user moves his finger greater than &lt;minDistance&gt;*&lt;cancelMultiplier&gt; in
     * the perpindicular direction. Eg if the drag is horizontal and the user moves his finger &lt;minDistance&gt;*&lt;cancelMultiplier&gt;
     * pixels vertically, this handler won&#x27;t consider the move part of a drag.
     */
    .handler(&#x27;drag&#x27;, {
      options: {
        minDistance: 6,
        horizontal: true,
        cancelMultiplier: 1.5
      },
      onStart: function (ev) {
        // For drag, require a parent to be registered with $mdGesture.register()
        if (!this.state.registeredParent) this.cancel();
      },
      onMove: function (ev, pointer) {
        var shouldStartDrag, shouldCancel;
        // Don&#x27;t scroll while deciding if this touchmove qualifies as a drag event.
        // If we don&#x27;t preventDefault touchmove events here, Android will assume we don&#x27;t
        // want to listen to anymore touch events. It will start scrolling and stop sending
        // touchmove events.
        ev.preventDefault();

        if (!this.state.dragPointer) {
          if (this.state.options.horizontal) {
            shouldStartDrag = Math.abs(pointer.distanceX) &gt; this.state.options.minDistance;
            shouldCancel = Math.abs(pointer.distanceY) &gt; this.state.options.minDistance * this.state.options.cancelMultiplier;
          } else {
            shouldStartDrag = Math.abs(pointer.distanceY) &gt; this.state.options.minDistance;
            shouldCancel = Math.abs(pointer.distanceX) &gt; this.state.options.minDistance * this.state.options.cancelMultiplier;
          }

          if (shouldStartDrag) {
            // Create a new pointer representing this drag, starting at this point where the drag started.
            this.state.dragPointer = makeStartPointer(ev);
            updatePointerState(ev, this.state.dragPointer);
            this.dispatchEvent(ev, &#x27;$md.dragstart&#x27;, this.state.dragPointer);

          } else if (shouldCancel) {
            this.cancel();
          }
        } else {
          this.dispatchDragMove(ev);
        }
      },
      // Only dispatch dragmove events every frame; any more is unnecessray
      dispatchDragMove: $$rAF.throttle(function (ev) {
        // Make sure the drag didn&#x27;t stop while waiting for the next frame
        if (this.state.isRunning) {
          updatePointerState(ev, this.state.dragPointer);
          this.dispatchEvent(ev, &#x27;$md.drag&#x27;, this.state.dragPointer);
        }
      }),
      onEnd: function (ev, pointer) {
        if (this.state.dragPointer) {
          updatePointerState(ev, this.state.dragPointer);
          this.dispatchEvent(ev, &#x27;$md.dragend&#x27;, this.state.dragPointer);
        }
      }
    })

    /*
     * The swipe handler will dispatch a swipe event if, on the end of a touch,
     * the velocity and distance were high enough.
     */
    .handler(&#x27;swipe&#x27;, {
      options: {
        minVelocity: 0.65,
        minDistance: 10
      },
      onEnd: function (ev, pointer) {
        var eventType;

        if (Math.abs(pointer.velocityX) &gt; this.state.options.minVelocity &amp;&amp;
          Math.abs(pointer.distanceX) &gt; this.state.options.minDistance) {
          eventType = pointer.directionX == &#x27;left&#x27; ? &#x27;$md.swipeleft&#x27; : &#x27;$md.swiperight&#x27;;
          this.dispatchEvent(ev, eventType);
        }
        else if (Math.abs(pointer.velocityY) &gt; this.state.options.minVelocity &amp;&amp;
          Math.abs(pointer.distanceY) &gt; this.state.options.minDistance) {
          eventType = pointer.directionY == &#x27;up&#x27; ? &#x27;$md.swipeup&#x27; : &#x27;$md.swipedown&#x27;;
          this.dispatchEvent(ev, eventType);
        }
      }
    });

}
MdGesture.$inject = [&quot;$$MdGestureHandler&quot;, &quot;$$rAF&quot;, &quot;$timeout&quot;];

/**
 * MdGestureHandler
 * A GestureHandler is an object which is able to dispatch custom dom events
 * based on native dom {touch,pointer,mouse}{start,move,end} events.
 *
 * A gesture will manage its lifecycle through the start,move,end, and cancel
 * functions, which are called by native dom events.
 *
 * A gesture has the concept of &#x27;options&#x27; (eg a swipe&#x27;s required velocity), which can be
 * overridden by elements registering through $mdGesture.register()
 */
function GestureHandler (name) {
  this.name = name;
  this.state = {};
}

function MdGestureHandler() {
  var hasJQuery =  (typeof window.jQuery !== &#x27;undefined&#x27;) &amp;&amp; (angular.element === window.jQuery);

  GestureHandler.prototype = {
    options: {},
    // jQuery listeners don&#x27;t work with custom DOMEvents, so we have to dispatch events
    // differently when jQuery is loaded
    dispatchEvent: hasJQuery ?  jQueryDispatchEvent : nativeDispatchEvent,

    // These are overridden by the registered handler
    onStart: angular.noop,
    onMove: angular.noop,
    onEnd: angular.noop,
    onCancel: angular.noop,

    // onStart sets up a new state for the handler, which includes options from the
    // nearest registered parent element of ev.target.
    start: function (ev, pointer) {
      if (this.state.isRunning) return;
      var parentTarget = this.getNearestParent(ev.target);
      // Get the options from the nearest registered parent
      var parentTargetOptions = parentTarget &amp;&amp; parentTarget.$mdGesture[this.name] || {};

      this.state = {
        isRunning: true,
        // Override the default options with the nearest registered parent&#x27;s options
        options: angular.extend({}, this.options, parentTargetOptions),
        // Pass in the registered parent node to the state so the onStart listener can use
        registeredParent: parentTarget
      };
      this.onStart(ev, pointer);
    },
    move: function (ev, pointer) {
      if (!this.state.isRunning) return;
      this.onMove(ev, pointer);
    },
    end: function (ev, pointer) {
      if (!this.state.isRunning) return;
      this.onEnd(ev, pointer);
      this.state.isRunning = false;
    },
    cancel: function (ev, pointer) {
      this.onCancel(ev, pointer);
      this.state = {};
    },

    // Find and return the nearest parent element that has been registered to
    // listen for this handler via $mdGesture.register(element, &#x27;handlerName&#x27;).
    getNearestParent: function (node) {
      var current = node;
      while (current) {
        if ((current.$mdGesture || {})[this.name]) {
          return current;
        }
        current = current.parentNode;
      }
      return null;
    },

    // Called from $mdGesture.register when an element reigsters itself with a handler.
    // Store the options the user gave on the DOMElement itself. These options will
    // be retrieved with getNearestParent when the handler starts.
    registerElement: function (element, options) {
      var self = this;
      element[0].$mdGesture = element[0].$mdGesture || {};
      element[0].$mdGesture[this.name] = options || {};
      element.on(&#x27;$destroy&#x27;, onDestroy);

      return onDestroy;

      function onDestroy() {
        delete element[0].$mdGesture[self.name];
        element.off(&#x27;$destroy&#x27;, onDestroy);
      }
    }
  };

  return GestureHandler;

  /*
   * Dispatch an event with jQuery
   * TODO: Make sure this sends bubbling events
   *
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg &#x27;click&#x27; or &#x27;$md.drag&#x27;)
   * @param eventPointer the pointer object that matches this event.
   */
  function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
    eventPointer = eventPointer || pointer;
    var eventObj = new angular.element.Event(eventType);

    eventObj.$material = true;
    eventObj.pointer = eventPointer;
    eventObj.srcEvent = srcEvent;

    angular.extend(eventObj, {
      clientX: eventPointer.x,
      clientY: eventPointer.y,
      screenX: eventPointer.x,
      screenY: eventPointer.y,
      pageX: eventPointer.x,
      pageY: eventPointer.y,
      ctrlKey: srcEvent.ctrlKey,
      altKey: srcEvent.altKey,
      shiftKey: srcEvent.shiftKey,
      metaKey: srcEvent.metaKey
    });
    angular.element(eventPointer.target).trigger(eventObj);
  }

  /*
   * NOTE: nativeDispatchEvent is very performance sensitive.
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg &#x27;click&#x27; or &#x27;$md.drag&#x27;)
   * @param eventPointer the pointer object that matches this event.
   */
  function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
    eventPointer = eventPointer || pointer;
    var eventObj;

    if (eventType === &#x27;click&#x27; || eventType == &#x27;mouseup&#x27; || eventType == &#x27;mousedown&#x27; ) {
      eventObj = document.createEvent(&#x27;MouseEvents&#x27;);
      eventObj.initMouseEvent(
        eventType, true, true, window, srcEvent.detail,
        eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y,
        srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey,
        srcEvent.button, srcEvent.relatedTarget || null
      );

    } else {
      eventObj = document.createEvent(&#x27;CustomEvent&#x27;);
      eventObj.initCustomEvent(eventType, true, true, {});
    }
    eventObj.$material = true;
    eventObj.pointer = eventPointer;
    eventObj.srcEvent = srcEvent;
    eventPointer.target.dispatchEvent(eventObj);
  }

}

/**
 * Attach Gestures: hook document and check shouldHijack clicks
 * ngInject
 */
function attachToDocument( $mdGesture, $$MdGestureHandler ) {

  // Polyfill document.contains for IE11.
  // TODO: move to util
  document.contains || (document.contains = function (node) {
    return document.body.contains(node);
  });

  if (!isInitialized &amp;&amp; $mdGesture.isHijackingClicks ) {
    /*
     * If hijack clicks is true, we preventDefault any click that wasn&#x27;t
     * sent by ngMaterial. This is because on older Android &amp; iOS, a false, or &#x27;ghost&#x27;,
     * click event will be sent ~400ms after a touchend event happens.
     * The only way to know if this click is real is to prevent any normal
     * click events, and add a flag to events sent by material so we know not to prevent those.
     * 
     * Two exceptions to click events that should be prevented are:
     *  - click events sent by the keyboard (eg form submit)
     *  - events that originate from an Ionic app
     */
    document.addEventListener(&#x27;click&#x27;    , clickHijacker     , true);
    document.addEventListener(&#x27;mouseup&#x27;  , mouseInputHijacker, true);
    document.addEventListener(&#x27;mousedown&#x27;, mouseInputHijacker, true);
    document.addEventListener(&#x27;focus&#x27;    , mouseInputHijacker, true);

    isInitialized = true;
  }

  function mouseInputHijacker(ev) {
    var isKeyClick = !ev.clientX &amp;&amp; !ev.clientY;
    if (!isKeyClick &amp;&amp; !ev.$material &amp;&amp; !ev.isIonicTap
      &amp;&amp; !isInputEventFromLabelClick(ev)) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }

  function clickHijacker(ev) {
    var isKeyClick = ev.clientX === 0 &amp;&amp; ev.clientY === 0;
    if (!isKeyClick &amp;&amp; !ev.$material &amp;&amp; !ev.isIonicTap
      &amp;&amp; !isInputEventFromLabelClick(ev)) {
      ev.preventDefault();
      ev.stopPropagation();
      lastLabelClickPos = null;
    } else {
      lastLabelClickPos = null;
      if (ev.target.tagName.toLowerCase() == &#x27;label&#x27;) {
        lastLabelClickPos = {x: ev.x, y: ev.y};
      }
    }
  }


  // Listen to all events to cover all platforms.
  var START_EVENTS = &#x27;mousedown touchstart pointerdown&#x27;;
  var MOVE_EVENTS = &#x27;mousemove touchmove pointermove&#x27;;
  var END_EVENTS = &#x27;mouseup mouseleave touchend touchcancel pointerup pointercancel&#x27;;

  angular.element(document)
    .on(START_EVENTS, gestureStart)
    .on(MOVE_EVENTS, gestureMove)
    .on(END_EVENTS, gestureEnd)
    // For testing
    .on(&#x27;$$mdGestureReset&#x27;, function gestureClearCache () {
      lastPointer = pointer = null;
    });

  /*
   * When a DOM event happens, run all registered gesture handlers&#x27; lifecycle
   * methods which match the DOM event.
   * Eg when a &#x27;touchstart&#x27; event happens, runHandlers(&#x27;start&#x27;) will call and
   * run &#x60;handler.cancel()&#x60; and &#x60;handler.start()&#x60; on all registered handlers.
   */
  function runHandlers(handlerEvent, event) {
    var handler;
    for (var name in HANDLERS) {
      handler = HANDLERS[name];
      if( handler instanceof $$MdGestureHandler ) {

        if (handlerEvent === &#x27;start&#x27;) {
          // Run cancel to reset any handlers&#x27; state
          handler.cancel();
        }
        handler[handlerEvent](event, pointer);

      }
    }
  }

  /*
   * gestureStart vets if a start event is legitimate (and not part of a &#x27;ghost click&#x27; from iOS/Android)
   * If it is legitimate, we initiate the pointer state and mark the current pointer&#x27;s type
   * For example, for a touchstart event, mark the current pointer as a &#x27;touch&#x27; pointer, so mouse events
   * won&#x27;t effect it.
   */
  function gestureStart(ev) {
    // If we&#x27;re already touched down, abort
    if (pointer) return;

    var now = +Date.now();

    // iOS &amp; old android bug: after a touch event, a click event is sent 350 ms later.
    // If &lt;400ms have passed, don&#x27;t allow an event of a different type than the previous event
    if (lastPointer &amp;&amp; !typesMatch(ev, lastPointer) &amp;&amp; (now - lastPointer.endTime &lt; 1500)) {
      return;
    }

    pointer = makeStartPointer(ev);

    runHandlers(&#x27;start&#x27;, ev);
  }
  /*
   * If a move event happens of the right type, update the pointer and run all the move handlers.
   * &quot;of the right type&quot;: if a mousemove happens but our pointer started with a touch event, do nothing.
   */
  function gestureMove(ev) {
    if (!pointer || !typesMatch(ev, pointer)) return;

    updatePointerState(ev, pointer);
    runHandlers(&#x27;move&#x27;, ev);
  }
  /*
   * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as &#x27;lastPointer&#x27;
   */
  function gestureEnd(ev) {
    if (!pointer || !typesMatch(ev, pointer)) return;

    updatePointerState(ev, pointer);
    pointer.endTime = +Date.now();

    runHandlers(&#x27;end&#x27;, ev);

    lastPointer = pointer;
    pointer = null;
  }

}
attachToDocument.$inject = [&quot;$mdGesture&quot;, &quot;$$MdGestureHandler&quot;];

// ********************
// Module Functions
// ********************

/*
 * Initiate the pointer. x, y, and the pointer&#x27;s type.
 */
function makeStartPointer(ev) {
  var point = getEventPoint(ev);
  var startPointer = {
    startTime: +Date.now(),
    target: ev.target,
    // &#x27;p&#x27; for pointer events, &#x27;m&#x27; for mouse, &#x27;t&#x27; for touch
    type: ev.type.charAt(0)
  };
  startPointer.startX = startPointer.x = point.pageX;
  startPointer.startY = startPointer.y = point.pageY;
  return startPointer;
}

/*
 * return whether the pointer&#x27;s type matches the event&#x27;s type.
 * Eg if a touch event happens but the pointer has a mouse type, return false.
 */
function typesMatch(ev, pointer) {
  return ev &amp;&amp; pointer &amp;&amp; ev.type.charAt(0) === pointer.type;
}

/**
 * Gets whether the given event is an input event that was caused by clicking on an
 * associated label element.
 *
 * This is necessary because the browser will, upon clicking on a label element, fire an
 * *extra* click event on its associated input (if any). mdGesture is able to flag the label
 * click as with &#x60;$material&#x60; correctly, but not the second input click.
 *
 * In order to determine whether an input event is from a label click, we compare the (x, y) for
 * the event to the (x, y) for the most recent label click (which is cleared whenever a non-label
 * click occurs). Unfortunately, there are no event properties that tie the input and the label
 * together (such as relatedTarget).
 *
 * @param {MouseEvent} event
 * @returns {boolean}
 */
function isInputEventFromLabelClick(event) {
  return lastLabelClickPos
      &amp;&amp; lastLabelClickPos.x == event.x
      &amp;&amp; lastLabelClickPos.y == event.y;
}

/*
 * Update the given pointer based upon the given DOMEvent.
 * Distance, velocity, direction, duration, etc
 */
function updatePointerState(ev, pointer) {
  var point = getEventPoint(ev);
  var x = pointer.x = point.pageX;
  var y = pointer.y = point.pageY;

  pointer.distanceX = x - pointer.startX;
  pointer.distanceY = y - pointer.startY;
  pointer.distance = Math.sqrt(
    pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY
  );

  pointer.directionX = pointer.distanceX &gt; 0 ? &#x27;right&#x27; : pointer.distanceX &lt; 0 ? &#x27;left&#x27; : &#x27;&#x27;;
  pointer.directionY = pointer.distanceY &gt; 0 ? &#x27;down&#x27; : pointer.distanceY &lt; 0 ? &#x27;up&#x27; : &#x27;&#x27;;

  pointer.duration = +Date.now() - pointer.startTime;
  pointer.velocityX = pointer.distanceX / pointer.duration;
  pointer.velocityY = pointer.distanceY / pointer.duration;
}

/*
 * Normalize the point where the DOM event happened whether it&#x27;s touch or mouse.
 * @returns point event obj with pageX and pageY on it.
 */
function getEventPoint(ev) {
  ev = ev.originalEvent || ev; // support jQuery events
  return (ev.touches &amp;&amp; ev.touches[0]) ||
    (ev.changedTouches &amp;&amp; ev.changedTouches[0]) ||
    ev;
}

(function() {
  &#x27;use strict&#x27;;

  var $mdUtil, $interpolate, $log;

  var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
  var WHITESPACE = /\s+/g;

  var FLEX_OPTIONS = [&#x27;grow&#x27;, &#x27;initial&#x27;, &#x27;auto&#x27;, &#x27;none&#x27;, &#x27;noshrink&#x27;, &#x27;nogrow&#x27; ];
  var LAYOUT_OPTIONS = [&#x27;row&#x27;, &#x27;column&#x27;];
  var ALIGNMENT_MAIN_AXIS= [ &quot;&quot;, &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, &quot;stretch&quot;, &quot;space-around&quot;, &quot;space-between&quot; ];
  var ALIGNMENT_CROSS_AXIS= [ &quot;&quot;, &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, &quot;stretch&quot; ];

  var config = {
    /**
     * Enable directive attribute-to-class conversions
     * Developers can use &#x60;&lt;body md-layout-css /&gt;&#x60; to quickly
     * disable the Layout directives and prohibit the injection of Layout classNames
     */
    enabled: true,

    /**
     * List of mediaQuery breakpoints and associated suffixes
     *
     *   [
     *    { suffix: &quot;sm&quot;, mediaQuery: &quot;screen and (max-width: 599px)&quot; },
     *    { suffix: &quot;md&quot;, mediaQuery: &quot;screen and (min-width: 600px) and (max-width: 959px)&quot; }
     *   ]
     */
    breakpoints: []
  };

  registerLayoutAPI( angular.module(&#x27;material.core.layout&#x27;, [&#x27;ng&#x27;]) );

  /**
   *   registerLayoutAPI()
   *
   *   The original ngMaterial Layout solution used attribute selectors and CSS.
   *
   *  &#x60;&#x60;&#x60;html
   *  &lt;div layout=&quot;column&quot;&gt; My Content &lt;/div&gt;
   *  &#x60;&#x60;&#x60;
   *
   *  &#x60;&#x60;&#x60;css
   *  [layout] {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  [layout=column] {
   *    flex-direction : column
   *  }
   *  &#x60;&#x60;&#x60;
   *
   *  Use of attribute selectors creates significant performance impacts in some
   *  browsers... mainly IE.
   *
   *  This module registers directives that allow the same layout attributes to be
   *  interpreted and converted to class selectors. The directive will add equivalent classes to each element that
   *  contains a Layout directive.
   *
   * &#x60;&#x60;&#x60;html
   *   &lt;div layout=&quot;column&quot; class=&quot;layout layout-column&quot;&gt; My Content &lt;/div&gt;
   *&#x60;&#x60;&#x60;
   *
   *  &#x60;&#x60;&#x60;css
   *  .layout {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  .layout-column {
   *    flex-direction : column
   *  }
   *  &#x60;&#x60;&#x60;
   */
  function registerLayoutAPI(module){
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;

    // NOTE: these are also defined in constants::MEDIA_PRIORITY and constants::MEDIA
    var BREAKPOINTS     = [ &quot;&quot;, &quot;xs&quot;, &quot;gt-xs&quot;, &quot;sm&quot;, &quot;gt-sm&quot;, &quot;md&quot;, &quot;gt-md&quot;, &quot;lg&quot;, &quot;gt-lg&quot;, &quot;xl&quot;, &quot;print&quot; ];
    var API_WITH_VALUES = [ &quot;layout&quot;, &quot;flex&quot;, &quot;flex-order&quot;, &quot;flex-offset&quot;, &quot;layout-align&quot; ];
    var API_NO_VALUES   = [ &quot;show&quot;, &quot;hide&quot;, &quot;layout-padding&quot;, &quot;layout-margin&quot; ];


    // Build directive registration functions for the standard Layout API... for all breakpoints.
    angular.forEach(BREAKPOINTS, function(mqb) {

      // Attribute directives with expected, observable value(s)
      angular.forEach( API_WITH_VALUES, function(name){
        var fullName = mqb ? name + &quot;-&quot; + mqb : name;
        module.directive( directiveNormalize(fullName), attributeWithObserve(fullName));
      });

      // Attribute directives with no expected value(s)
      angular.forEach( API_NO_VALUES, function(name){
        var fullName = mqb ? name + &quot;-&quot; + mqb : name;
        module.directive( directiveNormalize(fullName), attributeWithoutValue(fullName));
      });

    });

    // Register other, special directive functions for the Layout features:
    module
      .directive(&#x27;mdLayoutCss&#x27;  , disableLayoutDirective )
      .directive(&#x27;ngCloak&#x27;      ,  buildCloakInterceptor(&#x27;ng-cloak&#x27;))

      .directive(&#x27;layoutWrap&#x27;   , attributeWithoutValue(&#x27;layout-wrap&#x27;))
      .directive(&#x27;layoutNowrap&#x27; , attributeWithoutValue(&#x27;layout-nowrap&#x27;))
      .directive(&#x27;layoutNoWrap&#x27; , attributeWithoutValue(&#x27;layout-no-wrap&#x27;))
      .directive(&#x27;layoutFill&#x27;   , attributeWithoutValue(&#x27;layout-fill&#x27;))

      // !! Deprecated attributes: use the &#x60;-lt&#x60; (aka less-than) notations

      .directive(&#x27;layoutLtMd&#x27;     , warnAttrNotSupported(&#x27;layout-lt-md&#x27;, true))
      .directive(&#x27;layoutLtLg&#x27;     , warnAttrNotSupported(&#x27;layout-lt-lg&#x27;, true))
      .directive(&#x27;flexLtMd&#x27;       , warnAttrNotSupported(&#x27;flex-lt-md&#x27;, true))
      .directive(&#x27;flexLtLg&#x27;       , warnAttrNotSupported(&#x27;flex-lt-lg&#x27;, true))

      .directive(&#x27;layoutAlignLtMd&#x27;, warnAttrNotSupported(&#x27;layout-align-lt-md&#x27;))
      .directive(&#x27;layoutAlignLtLg&#x27;, warnAttrNotSupported(&#x27;layout-align-lt-lg&#x27;))
      .directive(&#x27;flexOrderLtMd&#x27;  , warnAttrNotSupported(&#x27;flex-order-lt-md&#x27;))
      .directive(&#x27;flexOrderLtLg&#x27;  , warnAttrNotSupported(&#x27;flex-order-lt-lg&#x27;))
      .directive(&#x27;offsetLtMd&#x27;     , warnAttrNotSupported(&#x27;flex-offset-lt-md&#x27;))
      .directive(&#x27;offsetLtLg&#x27;     , warnAttrNotSupported(&#x27;flex-offset-lt-lg&#x27;))

      .directive(&#x27;hideLtMd&#x27;       , warnAttrNotSupported(&#x27;hide-lt-md&#x27;))
      .directive(&#x27;hideLtLg&#x27;       , warnAttrNotSupported(&#x27;hide-lt-lg&#x27;))
      .directive(&#x27;showLtMd&#x27;       , warnAttrNotSupported(&#x27;show-lt-md&#x27;))
      .directive(&#x27;showLtLg&#x27;       , warnAttrNotSupported(&#x27;show-lt-lg&#x27;));

    /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function directiveNormalize(name) {
      return name
        .replace(PREFIX_REGEXP, &#x27;&#x27;)
        .replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        });
    }

  }

  /**
   * Special directive that will disable ALL Layout conversions of layout
   * attribute(s) to classname(s).
   *
   * &lt;link rel=&quot;stylesheet&quot; href=&quot;angular-material.min.css&quot;&gt;
   * &lt;link rel=&quot;stylesheet&quot; href=&quot;angular-material.layout.css&quot;&gt;
   *
   * &lt;body md-layout-css&gt;
   *  ...
   * &lt;/body&gt;
   *
   * Note: Using md-layout-css directive requires the developer to load the Material
   * Layout Attribute stylesheet (which only uses attribute selectors):
   *
   *       &#x60;angular-material.layout.css&#x60;
   *
   * Another option is to use the LayoutProvider to configure and disable the attribute
   * conversions; this would obviate the use of the &#x60;md-layout-css&#x60; directive
   *
   */
  function disableLayoutDirective() {
    return {
      restrict : &#x27;A&#x27;,
      priority : &#x27;900&#x27;,
      compile  : function(element, attr) {
        config.enabled = false;
        return angular.noop;
      }
    };
  }

  /**
   * Tail-hook ngCloak to delay the uncloaking while Layout transformers
   * finish processing. Eliminates flicker with Material.Layoouts
   */
  function buildCloakInterceptor(className) {
    return [ &#x27;$timeout&#x27;, function($timeout){
      return {
        restrict : &#x27;A&#x27;,
        priority : -10,   // run after normal ng-cloak
        compile  : function( element ) {
          if (!config.enabled) return angular.noop;

          // Re-add the cloak
          element.addClass(className);

          return function( scope, element ) {
            // Wait while layout injectors configure, then uncloak
            // NOTE: $rAF does not delay enough... and this is a 1x-only event,
            //       $timeout is acceptable.
            $timeout( function(){
              element.removeClass(className);
            }, 10, false);
          };
        }
      };
    }];
  }


  // *********************************************************************************
  //
  // These functions create registration functions for ngMaterial Layout attribute directives
  // This provides easy translation to switch ngMaterial attribute selectors to
  // CLASS selectors and directives; which has huge performance implications
  // for IE Browsers
  //
  // *********************************************************************************

  /**
   * Creates a directive registration function where a possible dynamic attribute
   * value will be observed/watched.
   * @param {string} className attribute name; eg &#x60;layout-gt-md&#x60; with value =&quot;row&quot;
   */
  function attributeWithObserve(className) {

    return [&#x27;$mdUtil&#x27;, &#x27;$interpolate&#x27;, &quot;$log&quot;, function(_$mdUtil_, _$interpolate_, _$log_) {
      $mdUtil = _$mdUtil_;
      $interpolate = _$interpolate_;
      $log = _$log_;

      return {
        restrict: &#x27;A&#x27;,
        compile: function(element, attr) {
          var linkFn;
          if (config.enabled) {
            // immediately replace static (non-interpolated) invalid values...

            validateAttributeUsage(className, attr, element, $log);

            validateAttributeValue( className,
              getNormalizedAttrValue(className, attr, &quot;&quot;),
              buildUpdateFn(element, className, attr)
            );

            linkFn = translateWithValueToCssClass;
          }

          // Use for postLink to account for transforms after ng-transclude.
          return linkFn || angular.noop;
        }
      };
    }];

    /**
     * Add as transformed class selector(s), then
     * remove the deprecated attribute selector
     */
    function translateWithValueToCssClass(scope, element, attrs) {
      var updateFn = updateClassWithValue(element, className, attrs);
      var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);

      updateFn(getNormalizedAttrValue(className, attrs, &quot;&quot;));
      scope.$on(&quot;$destroy&quot;, function() { unwatch() });
    }
  }

  /**
   * Creates a registration function for ngMaterial Layout attribute directive.
   * This is a &#x60;simple&#x60; transpose of attribute usage to class usage; where we ignore
   * any attribute value
   */
  function attributeWithoutValue(className) {
    return [&#x27;$mdUtil&#x27;, &#x27;$interpolate&#x27;, &quot;$log&quot;, function(_$mdUtil_, _$interpolate_, _$log_) {
      $mdUtil = _$mdUtil_;
      $interpolate = _$interpolate_;
      $log = _$log_;

      return {
        restrict: &#x27;A&#x27;,
        compile: function(element, attr) {
          var linkFn;
          if (config.enabled) {
            // immediately replace static (non-interpolated) invalid values...

            validateAttributeValue( className,
              getNormalizedAttrValue(className, attr, &quot;&quot;),
              buildUpdateFn(element, className, attr)
            );

            translateToCssClass(null, element);

            // Use for postLink to account for transforms after ng-transclude.
            linkFn = translateToCssClass;
          }

          return linkFn || angular.noop;
        }
      };
    }];

    /**
     * Add as transformed class selector, then
     * remove the deprecated attribute selector
     */
    function translateToCssClass(scope, element) {
      element.addClass(className);
    }
  }



  /**
   * After link-phase, do NOT remove deprecated layout attribute selector.
   * Instead watch the attribute so interpolated data-bindings to layout
   * selectors will continue to be supported.
   *
   * $observe() the className and update with new class (after removing the last one)
   *
   * e.g. &#x60;layout=&quot;{{layoutDemo.direction}}&quot;&#x60; will update...
   *
   * NOTE: The value must match one of the specified styles in the CSS.
   * For example &#x60;flex-gt-md=&quot;{{size}}&#x60;  where &#x60;scope.size == 47&#x60; will NOT work since
   * only breakpoints for 0, 5, 10, 15... 100, 33, 34, 66, 67 are defined.
   *
   */
  function updateClassWithValue(element, className) {
    var lastClass;

    return function updateClassFn(newValue) {
      var value = validateAttributeValue(className, newValue || &quot;&quot;);
      if ( angular.isDefined(value) ) {
        if (lastClass) element.removeClass(lastClass);
        lastClass = !value ? className : className + &quot;-&quot; + value.replace(WHITESPACE, &quot;-&quot;);
        element.addClass(lastClass);
      }
    };
  }

  /**
   * Provide console warning that this layout attribute has been deprecated
   *
   */
  function warnAttrNotSupported(className) {
    var parts = className.split(&quot;-&quot;);
    return [&quot;$log&quot;, function($log) {
      $log.warn(className + &quot;has been deprecated. Please use a &#x60;&quot; + parts[0] + &quot;-gt-&lt;xxx&gt;&#x60; variant.&quot;);
      return angular.noop;
    }];
  }

  /**
   * Centralize warnings for known flexbox issues (especially IE-related issues)
   */
  function validateAttributeUsage(className, attr, element, $log){
    var message, usage, url;
    var nodeName = element[0].nodeName.toLowerCase();

    switch(className.replace(SUFFIXES,&quot;&quot;)) {
      case &quot;flex&quot;:
        if ((nodeName == &quot;md-button&quot;) || (nodeName == &quot;fieldset&quot;)){
          // @see https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers
          // Use &lt;div flex&gt; wrapper inside (preferred) or outside

          usage = &quot;&lt;&quot; + nodeName + &quot; &quot; + className + &quot;&gt;&lt;/&quot; + nodeName + &quot;&gt;&quot;;
          url = &quot;https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers&quot;;
          message = &quot;Markup &#x27;{0}&#x27; may not work as expected in IE Browsers. Consult &#x27;{1}&#x27; for details.&quot;;

          $log.warn( $mdUtil.supplant(message, [usage, url]) );
        }
    }

  }


  /**
   * For the Layout attribute value, validate or replace with default
   * fallback value
   */
  function validateAttributeValue(className, value, updateFn) {
    var origValue = value;

    if (!needsInterpolation(value)) {
      switch (className.replace(SUFFIXES,&quot;&quot;)) {
        case &#x27;layout&#x27;        :
          if ( !findIn(value, LAYOUT_OPTIONS) ) {
            value = LAYOUT_OPTIONS[0];    // &#x27;row&#x27;;
          }
          break;

        case &#x27;flex&#x27;          :
          if (!findIn(value, FLEX_OPTIONS)) {
            if (isNaN(value)) {
              value = &#x27;&#x27;;
            }
          }
          break;

        case &#x27;flex-offset&#x27; :
        case &#x27;flex-order&#x27;    :
          if (!value || isNaN(+value)) {
            value = &#x27;0&#x27;;
          }
          break;

        case &#x27;layout-align&#x27;  :
          var axis = extractAlignAxis(value);
          value = $mdUtil.supplant(&quot;{main}-{cross}&quot;,axis);
          break;

        case &#x27;layout-padding&#x27; :
        case &#x27;layout-margin&#x27;  :
        case &#x27;layout-fill&#x27;    :
        case &#x27;layout-wrap&#x27;    :
        case &#x27;layout-nowrap&#x27;  :
        case &#x27;layout-nowrap&#x27; :
          value = &#x27;&#x27;;
          break;
      }

      if (value != origValue) {
        (updateFn || angular.noop)(value);
      }
    }

    return value;
  }

  /**
   * Replace current attribute value with fallback value
   */
  function buildUpdateFn(element, className, attrs) {
    return function updateAttrValue(fallback) {
      if (!needsInterpolation(fallback)) {
        // Do not modify the element&#x27;s attribute value; so
        // uses &#x27;&lt;ui-layout layout=&quot;/api/sidebar.html&quot; /&gt;&#x27; will not
        // be affected. Just update the attrs value.
        attrs[attrs.$normalize(className)] = fallback;
      }
    };
  }

  /**
   * See if the original value has interpolation symbols:
   * e.g.  flex-gt-md=&quot;{{triggerPoint}}&quot;
   */
  function needsInterpolation(value) {
    return (value || &quot;&quot;).indexOf($interpolate.startSymbol()) &gt; -1;
  }

  function getNormalizedAttrValue(className, attrs, defaultVal) {
    var normalizedAttr = attrs.$normalize(className);
    return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, &quot;-&quot;) : defaultVal || null;
  }

  function findIn(item, list, replaceWith) {
    item = replaceWith &amp;&amp; item ? item.replace(WHITESPACE, replaceWith) : item;

    var found = false;
    if (item) {
      list.forEach(function(it) {
        it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
        found = found || (it === item);
      });
    }
    return found;
  }

  function extractAlignAxis(attrValue) {
    var axis = {
      main : &quot;start&quot;,
      cross: &quot;stretch&quot;
    }, values;

    attrValue = (attrValue || &quot;&quot;);

    if ( attrValue.indexOf(&quot;-&quot;) == 0 || attrValue.indexOf(&quot; &quot;) == 0) {
      // For missing main-axis values
      attrValue = &quot;none&quot; + attrValue;
    }

    values = attrValue.toLowerCase().trim().replace(WHITESPACE, &quot;-&quot;).split(&quot;-&quot;);
    if ( values.length &amp;&amp; (values[0] === &quot;space&quot;) ) {
      // for main-axis values of &quot;space-around&quot; or &quot;space-between&quot;
      values = [ values[0]+&quot;-&quot;+values[1],values[2] ];
    }

    if ( values.length &gt; 0 ) axis.main  = values[0] || axis.main;
    if ( values.length &gt; 1 ) axis.cross = values[1] || axis.cross;

    if ( ALIGNMENT_MAIN_AXIS.indexOf(axis.main) &lt; 0 )   axis.main = &quot;start&quot;;
    if ( ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) &lt; 0 ) axis.cross = &quot;stretch&quot;;

    return axis;
  }


})();

angular.module(&#x27;material.core&#x27;)
  .provider(&#x27;$$interimElement&#x27;, InterimElementProvider);

/*
 * @ngdoc service
 * @name $$interimElement
 * @module material.core
 *
 * @description
 *
 * Factory that contructs &#x60;$$interimElement.$service&#x60; services.
 * Used internally in material design for elements that appear on screen temporarily.
 * The service provides a promise-like API for interacting with the temporary
 * elements.
 *
 * &#x60;&#x60;&#x60;js
 * app.service(&#x27;$mdToast&#x27;, function($$interimElement) {
 *   var $mdToast = $$interimElement(toastDefaultOptions);
 *   return $mdToast;
 * });
 * &#x60;&#x60;&#x60;
 * @param {object=} defaultOptions Options used by default for the &#x60;show&#x60; method on the service.
 *
 * @returns {$$interimElement.$service}
 *
 */

function InterimElementProvider() {
  createInterimElementProvider.$get = InterimElementFactory;
  InterimElementFactory.$inject = [&quot;$document&quot;, &quot;$q&quot;, &quot;$$q&quot;, &quot;$rootScope&quot;, &quot;$timeout&quot;, &quot;$rootElement&quot;, &quot;$animate&quot;, &quot;$mdUtil&quot;, &quot;$mdCompiler&quot;, &quot;$mdTheming&quot;, &quot;$injector&quot;];
  return createInterimElementProvider;

  /**
   * Returns a new provider which allows configuration of a new interimElement
   * service. Allows configuration of default options &amp; methods for options,
   * as well as configuration of &#x27;preset&#x27; methods (eg dialog.basic(): basic is a preset method)
   */
  function createInterimElementProvider(interimFactoryName) {
    var EXPOSED_METHODS = [&#x27;onHide&#x27;, &#x27;onShow&#x27;, &#x27;onRemove&#x27;];

    var customMethods = {};
    var providerConfig = {
      presets: {}
    };

    var provider = {
      setDefaults: setDefaults,
      addPreset: addPreset,
      addMethod: addMethod,
      $get: factory
    };

    /**
     * all interim elements will come with the &#x27;build&#x27; preset
     */
    provider.addPreset(&#x27;build&#x27;, {
      methods: [&#x27;controller&#x27;, &#x27;controllerAs&#x27;, &#x27;resolve&#x27;,
        &#x27;template&#x27;, &#x27;templateUrl&#x27;, &#x27;themable&#x27;, &#x27;transformTemplate&#x27;, &#x27;parent&#x27;]
    });

    factory.$inject = [&quot;$$interimElement&quot;, &quot;$injector&quot;];
    return provider;

    /**
     * Save the configured defaults to be used when the factory is instantiated
     */
    function setDefaults(definition) {
      providerConfig.optionsFactory = definition.options;
      providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
      return provider;
    }

    /**
     * Add a method to the factory that isn&#x27;t specific to any interim element operations
     */

    function addMethod(name, fn) {
      customMethods[name] = fn;
      return provider;
    }

    /**
     * Save the configured preset to be used when the factory is instantiated
     */
    function addPreset(name, definition) {
      definition = definition || {};
      definition.methods = definition.methods || [];
      definition.options = definition.options || function() { return {}; };

      if (/^cancel|hide|show$/.test(name)) {
        throw new Error(&quot;Preset &#x27;&quot; + name + &quot;&#x27; in &quot; + interimFactoryName + &quot; is reserved!&quot;);
      }
      if (definition.methods.indexOf(&#x27;_options&#x27;) &gt; -1) {
        throw new Error(&quot;Method &#x27;_options&#x27; in &quot; + interimFactoryName + &quot; is reserved!&quot;);
      }
      providerConfig.presets[name] = {
        methods: definition.methods.concat(EXPOSED_METHODS),
        optionsFactory: definition.options,
        argOption: definition.argOption
      };
      return provider;
    }

    function addPresetMethod(presetName, methodName, method) {
      providerConfig.presets[presetName][methodName] = method;
    }

    /**
     * Create a factory that has the given methods &amp; defaults implementing interimElement
     */
    /* ngInject */
    function factory($$interimElement, $injector) {
      var defaultMethods;
      var defaultOptions;
      var interimElementService = $$interimElement();

      /*
       * publicService is what the developer will be using.
       * It has methods hide(), cancel(), show(), build(), and any other
       * presets which were set during the config phase.
       */
      var publicService = {
        hide: interimElementService.hide,
        cancel: interimElementService.cancel,
        show: showInterimElement,

        // Special internal method to destroy an interim element without animations
        // used when navigation changes causes a $scope.$destroy() action
        destroy : destroyInterimElement
      };


      defaultMethods = providerConfig.methods || [];
      // This must be invoked after the publicService is initialized
      defaultOptions = invokeFactory(providerConfig.optionsFactory, {});

      // Copy over the simple custom methods
      angular.forEach(customMethods, function(fn, name) {
        publicService[name] = fn;
      });

      angular.forEach(providerConfig.presets, function(definition, name) {
        var presetDefaults = invokeFactory(definition.optionsFactory, {});
        var presetMethods = (definition.methods || []).concat(defaultMethods);

        // Every interimElement built with a preset has a field called &#x60;$type&#x60;,
        // which matches the name of the preset.
        // Eg in preset &#x27;confirm&#x27;, options.$type === &#x27;confirm&#x27;
        angular.extend(presetDefaults, { $type: name });

        // This creates a preset class which has setter methods for every
        // method given in the &#x60;.addPreset()&#x60; function, as well as every
        // method given in the &#x60;.setDefaults()&#x60; function.
        //
        // @example
        // .setDefaults({
        //   methods: [&#x27;hasBackdrop&#x27;, &#x27;clickOutsideToClose&#x27;, &#x27;escapeToClose&#x27;, &#x27;targetEvent&#x27;],
        //   options: dialogDefaultOptions
        // })
        // .addPreset(&#x27;alert&#x27;, {
        //   methods: [&#x27;title&#x27;, &#x27;ok&#x27;],
        //   options: alertDialogOptions
        // })
        //
        // Set values will be passed to the options when interimElement.show() is called.
        function Preset(opts) {
          this._options = angular.extend({}, presetDefaults, opts);
        }
        angular.forEach(presetMethods, function(name) {
          Preset.prototype[name] = function(value) {
            this._options[name] = value;
            return this;
          };
        });

        // Create shortcut method for one-linear methods
        if (definition.argOption) {
          var methodName = &#x27;show&#x27; + name.charAt(0).toUpperCase() + name.slice(1);
          publicService[methodName] = function(arg) {
            var config = publicService[name](arg);
            return publicService.show(config);
          };
        }

        // eg $mdDialog.alert() will return a new alert preset
        publicService[name] = function(arg) {
          // If argOption is supplied, eg &#x60;argOption: &#x27;content&#x27;&#x60;, then we assume
          // if the argument is not an options object then it is the &#x60;argOption&#x60; option.
          //
          // @example &#x60;$mdToast.simple(&#x27;hello&#x27;)&#x60; // sets options.content to hello
          //                                     // because argOption === &#x27;content&#x27;
          if (arguments.length &amp;&amp; definition.argOption &amp;&amp;
              !angular.isObject(arg) &amp;&amp; !angular.isArray(arg))  {

            return (new Preset())[definition.argOption](arg);

          } else {
            return new Preset(arg);
          }

        };
      });

      return publicService;

      /**
       *
       */
      function showInterimElement(opts) {
        // opts is either a preset which stores its options on an _options field,
        // or just an object made up of options
        opts = opts || { };
        if (opts._options) opts = opts._options;

        return interimElementService.show(
          angular.extend({}, defaultOptions, opts)
        );
      }

      /**
       *  Special method to hide and destroy an interimElement WITHOUT
       *  any &#x27;leave&#x60; or hide animations ( an immediate force hide/remove )
       *
       *  NOTE: This calls the onRemove() subclass method for each component...
       *  which must have code to respond to &#x60;options.$destroy == true&#x60;
       */
      function destroyInterimElement(opts) {
          return interimElementService.destroy(opts);
      }

      /**
       * Helper to call $injector.invoke with a local of the factory name for
       * this provider.
       * If an $mdDialog is providing options for a dialog and tries to inject
       * $mdDialog, a circular dependency error will happen.
       * We get around that by manually injecting $mdDialog as a local.
       */
      function invokeFactory(factory, defaultVal) {
        var locals = {};
        locals[interimFactoryName] = publicService;
        return $injector.invoke(factory || function() { return defaultVal; }, {}, locals);
      }

    }

  }

  /* ngInject */
  function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate,
                                 $mdUtil, $mdCompiler, $mdTheming, $injector ) {
    return function createInterimElementService() {
      var SHOW_CANCELLED = false;

      /*
       * @ngdoc service
       * @name $$interimElement.$service
       *
       * @description
       * A service used to control inserting and removing an element into the DOM.
       *
       */
      var service, stack = [];

      // Publish instance $$interimElement service;
      // ... used as $mdDialog, $mdToast, $mdMenu, and $mdSelect

      return service = {
        show: show,
        hide: hide,
        cancel: cancel,
        destroy : destroy,
        $injector_: $injector
      };

      /*
       * @ngdoc method
       * @name $$interimElement.$service#show
       * @kind function
       *
       * @description
       * Adds the &#x60;$interimElement&#x60; to the DOM and returns a special promise that will be resolved or rejected
       * with hide or cancel, respectively. To external cancel/hide, developers should use the
       *
       * @param {*} options is hashMap of settings
       * @returns a Promise
       *
       */
      function show(options) {
        options = options || {};
        var interimElement = new InterimElement(options || {});
        var hideExisting = !options.skipHide &amp;&amp; stack.length ? service.hide() : $q.when(true);

        // This hide()s only the current interim element before showing the next, new one
        // NOTE: this is not reversible (e.g. interim elements are not stackable)

        hideExisting.finally(function() {

          stack.push(interimElement);
          interimElement
            .show()
            .catch(function( reason ) {
              //$log.error(&quot;InterimElement.show() error: &quot; + reason );
              return reason;
            });

        });

        // Return a promise that will be resolved when the interim
        // element is hidden or cancelled...

        return interimElement.deferred.promise;
      }

      /*
       * @ngdoc method
       * @name $$interimElement.$service#hide
       * @kind function
       *
       * @description
       * Removes the &#x60;$interimElement&#x60; from the DOM and resolves the promise returned from &#x60;show&#x60;
       *
       * @param {*} resolveParam Data to resolve the promise with
       * @returns a Promise that will be resolved after the element has been removed.
       *
       */
      function hide(reason, options) {
        if ( !stack.length ) return $q.when(reason);
        options = options || {};

        if (options.closeAll) {
          var promise = $q.all(stack.reverse().map(closeElement));
          stack = [];
          return promise;
        } else if (options.closeTo !== undefined) {
          return $q.all(stack.splice(options.closeTo).map(closeElement));
        } else {
          var interim = stack.pop();
          return closeElement(interim);
        }

        function closeElement(interim) {
          interim
            .remove(reason, false, options || { })
            .catch(function( reason ) {
              //$log.error(&quot;InterimElement.hide() error: &quot; + reason );
              return reason;
            });
          return interim.deferred.promise;
        }
      }

      /*
       * @ngdoc method
       * @name $$interimElement.$service#cancel
       * @kind function
       *
       * @description
       * Removes the &#x60;$interimElement&#x60; from the DOM and rejects the promise returned from &#x60;show&#x60;
       *
       * @param {*} reason Data to reject the promise with
       * @returns Promise that will be resolved after the element has been removed.
       *
       */
      function cancel(reason, options) {
        var interim = stack.shift();
        if ( !interim ) return $q.when(reason);

        interim
          .remove(reason, true, options || { })
          .catch(function( reason ) {
            //$log.error(&quot;InterimElement.cancel() error: &quot; + reason );
            return reason;
          });

        return interim.deferred.promise;
      }

      /*
       * Special method to quick-remove the interim element without animations
       * Note: interim elements are in &quot;interim containers&quot;
       */
      function destroy(target) {
        var interim = !target ? stack.shift() : null;
        var cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;

        if (cntr) {
            // Try to find the interim element in the stack which corresponds to the supplied DOM element.
            var filtered = stack.filter(function(entry) {
                  var currNode = entry.options.element[0];
                  return  (currNode === cntr);
                });

            // Note: this function might be called when the element already has been removed, in which
            //       case we won&#x27;t find any matches. That&#x27;s ok.
            if (filtered.length &gt; 0) {
              interim = filtered[0];
              stack.splice(stack.indexOf(interim), 1);
            }
        }

        return interim ? interim.remove(SHOW_CANCELLED, false, {&#x27;$destroy&#x27;:true}) : $q.when(SHOW_CANCELLED);
      }

      /*
       * Internal Interim Element Object
       * Used internally to manage the DOM element and related data
       */
      function InterimElement(options) {
        var self, element, showAction = $q.when(true);

        options = configureScopeAndTransitions(options);

        return self = {
          options : options,
          deferred: $q.defer(),
          show    : createAndTransitionIn,
          remove  : transitionOutAndRemove
        };

        /**
         * Compile, link, and show this interim element
         * Use optional autoHided and transition-in effects
         */
        function createAndTransitionIn() {
          return $q(function(resolve, reject){

            compileElement(options)
              .then(function( compiledData ) {
                element = linkElement( compiledData, options );

                showAction = showElement(element, options, compiledData.controller)
                  .then(resolve, rejectAll );

              }, rejectAll);

            function rejectAll(fault) {
              // Force the &#x27;$md&lt;xxx&gt;.show()&#x27; promise to reject
              self.deferred.reject(fault);

              // Continue rejection propagation
              reject(fault);
            }
          });
        }

        /**
         * After the show process has finished/rejected:
         * - announce &#x27;removing&#x27;,
         * - perform the transition-out, and
         * - perform optional clean up scope.
         */
        function transitionOutAndRemove(response, isCancelled, opts) {

          // abort if the show() and compile failed
          if ( !element ) return $q.when(false);

          options = angular.extend(options || {}, opts || {});
          options.cancelAutoHide &amp;&amp; options.cancelAutoHide();
          options.element.triggerHandler(&#x27;$mdInterimElementRemove&#x27;);

          if ( options.$destroy === true ) {

            return hideElement(options.element, options).then(function(){
              (isCancelled &amp;&amp; rejectAll(response)) || resolveAll(response);
            });

          } else {

            $q.when(showAction)
                .finally(function() {
                  hideElement(options.element, options).then(function() {

                    (isCancelled &amp;&amp; rejectAll(response)) || resolveAll(response);

                  }, rejectAll);
                });

            return self.deferred.promise;
          }


          /**
           * The &#x60;show()&#x60; returns a promise that will be resolved when the interim
           * element is hidden or cancelled...
           */
          function resolveAll(response) {
            self.deferred.resolve(response);
          }

          /**
           * Force the &#x27;$md&lt;xxx&gt;.show()&#x27; promise to reject
           */
          function rejectAll(fault) {
            self.deferred.reject(fault);
          }
        }

        /**
         * Prepare optional isolated scope and prepare $animate with default enter and leave
         * transitions for the new element instance.
         */
        function configureScopeAndTransitions(options) {
          options = options || { };
          if ( options.template ) {
            options.template = $mdUtil.processTemplate(options.template);
          }

          return angular.extend({
            preserveScope: false,
            cancelAutoHide : angular.noop,
            scope: options.scope || $rootScope.$new(options.isolateScope),

            /**
             * Default usage to enable $animate to transition-in; can be easily overridden via &#x27;options&#x27;
             */
            onShow: function transitionIn(scope, element, options) {
              return $animate.enter(element, options.parent);
            },

            /**
             * Default usage to enable $animate to transition-out; can be easily overridden via &#x27;options&#x27;
             */
            onRemove: function transitionOut(scope, element) {
              // Element could be undefined if a new element is shown before
              // the old one finishes compiling.
              return element &amp;&amp; $animate.leave(element) || $q.when();
            }
          }, options );

        }

        /**
         * Compile an element with a templateUrl, controller, and locals
         */
        function compileElement(options) {

          var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;

          return compiled || $q(function (resolve) {
              resolve({
                locals: {},
                link: function () {
                  return options.element;
                }
              });
            });
        }

        /**
         *  Link an element with compiled configuration
         */
        function linkElement(compileData, options){
          angular.extend(compileData.locals, options);

          var element = compileData.link(options.scope);

          // Search for parent at insertion time, if not specified
          options.element = element;
          options.parent = findParent(element, options);
          if (options.themable) $mdTheming(element);

          return element;
        }

        /**
         * Search for parent at insertion time, if not specified
         */
        function findParent(element, options) {
          var parent = options.parent;

          // Search for parent at insertion time, if not specified
          if (angular.isFunction(parent)) {
            parent = parent(options.scope, element, options);
          } else if (angular.isString(parent)) {
            parent = angular.element($document[0].querySelector(parent));
          } else {
            parent = angular.element(parent);
          }

          // If parent querySelector/getter function fails, or it&#x27;s just null,
          // find a default.
          if (!(parent || {}).length) {
            var el;
            if ($rootElement[0] &amp;&amp; $rootElement[0].querySelector) {
              el = $rootElement[0].querySelector(&#x27;:not(svg) &gt; body&#x27;);
            }
            if (!el) el = $rootElement[0];
            if (el.nodeName == &#x27;#comment&#x27;) {
              el = $document[0].body;
            }
            return angular.element(el);
          }

          return parent;
        }

        /**
         * If auto-hide is enabled, start timer and prepare cancel function
         */
        function startAutoHide() {
          var autoHideTimer, cancelAutoHide = angular.noop;

          if (options.hideDelay) {
            autoHideTimer = $timeout(service.hide, options.hideDelay) ;
            cancelAutoHide = function() {
              $timeout.cancel(autoHideTimer);
            }
          }

          // Cache for subsequent use
          options.cancelAutoHide = function() {
            cancelAutoHide();
            options.cancelAutoHide = undefined;
          }
        }

        /**
         * Show the element ( with transitions), notify complete and start
         * optional auto-Hide
         */
        function showElement(element, options, controller) {
          // Trigger onShowing callback before the &#x60;show()&#x60; starts
          var notifyShowing = options.onShowing || angular.noop;
          // Trigger onComplete callback when the &#x60;show()&#x60; finishes
          var notifyComplete = options.onComplete || angular.noop;

          notifyShowing(options.scope, element, options, controller);

          return $q(function (resolve, reject) {
            try {
              // Start transitionIn
              $q.when(options.onShow(options.scope, element, options, controller))
                .then(function () {
                  notifyComplete(options.scope, element, options);
                  startAutoHide();

                  resolve(element);

                }, reject );

            } catch(e) {
              reject(e.message);
            }
          });
        }

        function hideElement(element, options) {
          var announceRemoving = options.onRemoving || angular.noop;

          return $$q(function (resolve, reject) {
            try {
              // Start transitionIn
              var action = $$q.when( options.onRemove(options.scope, element, options) || true );

              // Trigger callback *before* the remove operation starts
              announceRemoving(element, action);

              if ( options.$destroy == true ) {

                // For $destroy, onRemove should be synchronous
                resolve(element);

              } else {

                // Wait until transition-out is done
                action.then(function () {

                  if (!options.preserveScope &amp;&amp; options.scope ) {
                    options.scope.$destroy();
                  }

                  resolve(element);

                }, reject );
              }

            } catch(e) {
              reject(e.message);
            }
          });
        }

      }
    };

  }

}

  /**
   * @ngdoc module
   * @name material.core.componentRegistry
   *
   * @description
   * A component instance registration service.
   * Note: currently this as a private service in the SideNav component.
   */
  angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdComponentRegistry&#x27;, ComponentRegistry);

  /*
   * @private
   * @ngdoc factory
   * @name ComponentRegistry
   * @module material.core.componentRegistry
   *
   */
  function ComponentRegistry($log, $q) {

    var self;
    var instances = [ ];
    var pendings = { };

    return self = {
      /**
       * Used to print an error when an instance for a handle isn&#x27;t found.
       */
      notFoundError: function(handle) {
        $log.error(&#x27;No instance found for handle&#x27;, handle);
      },
      /**
       * Return all registered instances as an array.
       */
      getInstances: function() {
        return instances;
      },

      /**
       * Get a registered instance.
       * @param handle the String handle to look up for a registered instance.
       */
      get: function(handle) {
        if ( !isValidID(handle) ) return null;

        var i, j, instance;
        for(i = 0, j = instances.length; i &lt; j; i++) {
          instance = instances[i];
          if(instance.$$mdHandle === handle) {
            return instance;
          }
        }
        return null;
      },

      /**
       * Register an instance.
       * @param instance the instance to register
       * @param handle the handle to identify the instance under.
       */
      register: function(instance, handle) {
        if ( !handle ) return angular.noop;

        instance.$$mdHandle = handle;
        instances.push(instance);
        resolveWhen();

        return deregister;

        /**
         * Remove registration for an instance
         */
        function deregister() {
          var index = instances.indexOf(instance);
          if (index !== -1) {
            instances.splice(index, 1);
          }
        }

        /**
         * Resolve any pending promises for this instance
         */
        function resolveWhen() {
          var dfd = pendings[handle];
          if ( dfd ) {
            dfd.resolve( instance );
            delete pendings[handle];
          }
        }
      },

      /**
       * Async accessor to registered component instance
       * If not available then a promise is created to notify
       * all listeners when the instance is registered.
       */
      when : function(handle) {
        if ( isValidID(handle) ) {
          var deferred = $q.defer();
          var instance = self.get(handle);

          if ( instance )  {
            deferred.resolve( instance );
          } else {
            pendings[handle] = deferred;
          }

          return deferred.promise;
        }
        return $q.reject(&quot;Invalid &#x60;md-component-id&#x60; value.&quot;);
      }

    };

    function isValidID(handle){
      return handle &amp;&amp; (handle !== &quot;&quot;);
    }

  }
  ComponentRegistry.$inject = [&quot;$log&quot;, &quot;$q&quot;];

angular.module(&#x27;material.core.theming.palette&#x27;, [])
.constant(&#x27;$mdColorPalette&#x27;, {
  &#x27;red&#x27;: {
    &#x27;50&#x27;: &#x27;#ffebee&#x27;,
    &#x27;100&#x27;: &#x27;#ffcdd2&#x27;,
    &#x27;200&#x27;: &#x27;#ef9a9a&#x27;,
    &#x27;300&#x27;: &#x27;#e57373&#x27;,
    &#x27;400&#x27;: &#x27;#ef5350&#x27;,
    &#x27;500&#x27;: &#x27;#f44336&#x27;,
    &#x27;600&#x27;: &#x27;#e53935&#x27;,
    &#x27;700&#x27;: &#x27;#d32f2f&#x27;,
    &#x27;800&#x27;: &#x27;#c62828&#x27;,
    &#x27;900&#x27;: &#x27;#b71c1c&#x27;,
    &#x27;A100&#x27;: &#x27;#ff8a80&#x27;,
    &#x27;A200&#x27;: &#x27;#ff5252&#x27;,
    &#x27;A400&#x27;: &#x27;#ff1744&#x27;,
    &#x27;A700&#x27;: &#x27;#d50000&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 300 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;400 500 600 700 A200 A400 A700&#x27;
  },
  &#x27;pink&#x27;: {
    &#x27;50&#x27;: &#x27;#fce4ec&#x27;,
    &#x27;100&#x27;: &#x27;#f8bbd0&#x27;,
    &#x27;200&#x27;: &#x27;#f48fb1&#x27;,
    &#x27;300&#x27;: &#x27;#f06292&#x27;,
    &#x27;400&#x27;: &#x27;#ec407a&#x27;,
    &#x27;500&#x27;: &#x27;#e91e63&#x27;,
    &#x27;600&#x27;: &#x27;#d81b60&#x27;,
    &#x27;700&#x27;: &#x27;#c2185b&#x27;,
    &#x27;800&#x27;: &#x27;#ad1457&#x27;,
    &#x27;900&#x27;: &#x27;#880e4f&#x27;,
    &#x27;A100&#x27;: &#x27;#ff80ab&#x27;,
    &#x27;A200&#x27;: &#x27;#ff4081&#x27;,
    &#x27;A400&#x27;: &#x27;#f50057&#x27;,
    &#x27;A700&#x27;: &#x27;#c51162&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;500 600 A200 A400 A700&#x27;
  },
  &#x27;purple&#x27;: {
    &#x27;50&#x27;: &#x27;#f3e5f5&#x27;,
    &#x27;100&#x27;: &#x27;#e1bee7&#x27;,
    &#x27;200&#x27;: &#x27;#ce93d8&#x27;,
    &#x27;300&#x27;: &#x27;#ba68c8&#x27;,
    &#x27;400&#x27;: &#x27;#ab47bc&#x27;,
    &#x27;500&#x27;: &#x27;#9c27b0&#x27;,
    &#x27;600&#x27;: &#x27;#8e24aa&#x27;,
    &#x27;700&#x27;: &#x27;#7b1fa2&#x27;,
    &#x27;800&#x27;: &#x27;#6a1b9a&#x27;,
    &#x27;900&#x27;: &#x27;#4a148c&#x27;,
    &#x27;A100&#x27;: &#x27;#ea80fc&#x27;,
    &#x27;A200&#x27;: &#x27;#e040fb&#x27;,
    &#x27;A400&#x27;: &#x27;#d500f9&#x27;,
    &#x27;A700&#x27;: &#x27;#aa00ff&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;300 400 A200 A400 A700&#x27;
  },
  &#x27;deep-purple&#x27;: {
    &#x27;50&#x27;: &#x27;#ede7f6&#x27;,
    &#x27;100&#x27;: &#x27;#d1c4e9&#x27;,
    &#x27;200&#x27;: &#x27;#b39ddb&#x27;,
    &#x27;300&#x27;: &#x27;#9575cd&#x27;,
    &#x27;400&#x27;: &#x27;#7e57c2&#x27;,
    &#x27;500&#x27;: &#x27;#673ab7&#x27;,
    &#x27;600&#x27;: &#x27;#5e35b1&#x27;,
    &#x27;700&#x27;: &#x27;#512da8&#x27;,
    &#x27;800&#x27;: &#x27;#4527a0&#x27;,
    &#x27;900&#x27;: &#x27;#311b92&#x27;,
    &#x27;A100&#x27;: &#x27;#b388ff&#x27;,
    &#x27;A200&#x27;: &#x27;#7c4dff&#x27;,
    &#x27;A400&#x27;: &#x27;#651fff&#x27;,
    &#x27;A700&#x27;: &#x27;#6200ea&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;300 400 A200&#x27;
  },
  &#x27;indigo&#x27;: {
    &#x27;50&#x27;: &#x27;#e8eaf6&#x27;,
    &#x27;100&#x27;: &#x27;#c5cae9&#x27;,
    &#x27;200&#x27;: &#x27;#9fa8da&#x27;,
    &#x27;300&#x27;: &#x27;#7986cb&#x27;,
    &#x27;400&#x27;: &#x27;#5c6bc0&#x27;,
    &#x27;500&#x27;: &#x27;#3f51b5&#x27;,
    &#x27;600&#x27;: &#x27;#3949ab&#x27;,
    &#x27;700&#x27;: &#x27;#303f9f&#x27;,
    &#x27;800&#x27;: &#x27;#283593&#x27;,
    &#x27;900&#x27;: &#x27;#1a237e&#x27;,
    &#x27;A100&#x27;: &#x27;#8c9eff&#x27;,
    &#x27;A200&#x27;: &#x27;#536dfe&#x27;,
    &#x27;A400&#x27;: &#x27;#3d5afe&#x27;,
    &#x27;A700&#x27;: &#x27;#304ffe&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;300 400 A200 A400&#x27;
  },
  &#x27;blue&#x27;: {
    &#x27;50&#x27;: &#x27;#e3f2fd&#x27;,
    &#x27;100&#x27;: &#x27;#bbdefb&#x27;,
    &#x27;200&#x27;: &#x27;#90caf9&#x27;,
    &#x27;300&#x27;: &#x27;#64b5f6&#x27;,
    &#x27;400&#x27;: &#x27;#42a5f5&#x27;,
    &#x27;500&#x27;: &#x27;#2196f3&#x27;,
    &#x27;600&#x27;: &#x27;#1e88e5&#x27;,
    &#x27;700&#x27;: &#x27;#1976d2&#x27;,
    &#x27;800&#x27;: &#x27;#1565c0&#x27;,
    &#x27;900&#x27;: &#x27;#0d47a1&#x27;,
    &#x27;A100&#x27;: &#x27;#82b1ff&#x27;,
    &#x27;A200&#x27;: &#x27;#448aff&#x27;,
    &#x27;A400&#x27;: &#x27;#2979ff&#x27;,
    &#x27;A700&#x27;: &#x27;#2962ff&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 300 400 A100&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;500 600 700 A200 A400 A700&#x27;
  },
  &#x27;light-blue&#x27;: {
    &#x27;50&#x27;: &#x27;#e1f5fe&#x27;,
    &#x27;100&#x27;: &#x27;#b3e5fc&#x27;,
    &#x27;200&#x27;: &#x27;#81d4fa&#x27;,
    &#x27;300&#x27;: &#x27;#4fc3f7&#x27;,
    &#x27;400&#x27;: &#x27;#29b6f6&#x27;,
    &#x27;500&#x27;: &#x27;#03a9f4&#x27;,
    &#x27;600&#x27;: &#x27;#039be5&#x27;,
    &#x27;700&#x27;: &#x27;#0288d1&#x27;,
    &#x27;800&#x27;: &#x27;#0277bd&#x27;,
    &#x27;900&#x27;: &#x27;#01579b&#x27;,
    &#x27;A100&#x27;: &#x27;#80d8ff&#x27;,
    &#x27;A200&#x27;: &#x27;#40c4ff&#x27;,
    &#x27;A400&#x27;: &#x27;#00b0ff&#x27;,
    &#x27;A700&#x27;: &#x27;#0091ea&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;600 700 800 900 A700&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;600 700 800 A700&#x27;
  },
  &#x27;cyan&#x27;: {
    &#x27;50&#x27;: &#x27;#e0f7fa&#x27;,
    &#x27;100&#x27;: &#x27;#b2ebf2&#x27;,
    &#x27;200&#x27;: &#x27;#80deea&#x27;,
    &#x27;300&#x27;: &#x27;#4dd0e1&#x27;,
    &#x27;400&#x27;: &#x27;#26c6da&#x27;,
    &#x27;500&#x27;: &#x27;#00bcd4&#x27;,
    &#x27;600&#x27;: &#x27;#00acc1&#x27;,
    &#x27;700&#x27;: &#x27;#0097a7&#x27;,
    &#x27;800&#x27;: &#x27;#00838f&#x27;,
    &#x27;900&#x27;: &#x27;#006064&#x27;,
    &#x27;A100&#x27;: &#x27;#84ffff&#x27;,
    &#x27;A200&#x27;: &#x27;#18ffff&#x27;,
    &#x27;A400&#x27;: &#x27;#00e5ff&#x27;,
    &#x27;A700&#x27;: &#x27;#00b8d4&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;700 800 900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;700 800 900&#x27;
  },
  &#x27;teal&#x27;: {
    &#x27;50&#x27;: &#x27;#e0f2f1&#x27;,
    &#x27;100&#x27;: &#x27;#b2dfdb&#x27;,
    &#x27;200&#x27;: &#x27;#80cbc4&#x27;,
    &#x27;300&#x27;: &#x27;#4db6ac&#x27;,
    &#x27;400&#x27;: &#x27;#26a69a&#x27;,
    &#x27;500&#x27;: &#x27;#009688&#x27;,
    &#x27;600&#x27;: &#x27;#00897b&#x27;,
    &#x27;700&#x27;: &#x27;#00796b&#x27;,
    &#x27;800&#x27;: &#x27;#00695c&#x27;,
    &#x27;900&#x27;: &#x27;#004d40&#x27;,
    &#x27;A100&#x27;: &#x27;#a7ffeb&#x27;,
    &#x27;A200&#x27;: &#x27;#64ffda&#x27;,
    &#x27;A400&#x27;: &#x27;#1de9b6&#x27;,
    &#x27;A700&#x27;: &#x27;#00bfa5&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;500 600 700 800 900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;500 600 700&#x27;
  },
  &#x27;green&#x27;: {
    &#x27;50&#x27;: &#x27;#e8f5e9&#x27;,
    &#x27;100&#x27;: &#x27;#c8e6c9&#x27;,
    &#x27;200&#x27;: &#x27;#a5d6a7&#x27;,
    &#x27;300&#x27;: &#x27;#81c784&#x27;,
    &#x27;400&#x27;: &#x27;#66bb6a&#x27;,
    &#x27;500&#x27;: &#x27;#4caf50&#x27;,
    &#x27;600&#x27;: &#x27;#43a047&#x27;,
    &#x27;700&#x27;: &#x27;#388e3c&#x27;,
    &#x27;800&#x27;: &#x27;#2e7d32&#x27;,
    &#x27;900&#x27;: &#x27;#1b5e20&#x27;,
    &#x27;A100&#x27;: &#x27;#b9f6ca&#x27;,
    &#x27;A200&#x27;: &#x27;#69f0ae&#x27;,
    &#x27;A400&#x27;: &#x27;#00e676&#x27;,
    &#x27;A700&#x27;: &#x27;#00c853&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;600 700 800 900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;600 700&#x27;
  },
  &#x27;light-green&#x27;: {
    &#x27;50&#x27;: &#x27;#f1f8e9&#x27;,
    &#x27;100&#x27;: &#x27;#dcedc8&#x27;,
    &#x27;200&#x27;: &#x27;#c5e1a5&#x27;,
    &#x27;300&#x27;: &#x27;#aed581&#x27;,
    &#x27;400&#x27;: &#x27;#9ccc65&#x27;,
    &#x27;500&#x27;: &#x27;#8bc34a&#x27;,
    &#x27;600&#x27;: &#x27;#7cb342&#x27;,
    &#x27;700&#x27;: &#x27;#689f38&#x27;,
    &#x27;800&#x27;: &#x27;#558b2f&#x27;,
    &#x27;900&#x27;: &#x27;#33691e&#x27;,
    &#x27;A100&#x27;: &#x27;#ccff90&#x27;,
    &#x27;A200&#x27;: &#x27;#b2ff59&#x27;,
    &#x27;A400&#x27;: &#x27;#76ff03&#x27;,
    &#x27;A700&#x27;: &#x27;#64dd17&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;700 800 900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;700 800 900&#x27;
  },
  &#x27;lime&#x27;: {
    &#x27;50&#x27;: &#x27;#f9fbe7&#x27;,
    &#x27;100&#x27;: &#x27;#f0f4c3&#x27;,
    &#x27;200&#x27;: &#x27;#e6ee9c&#x27;,
    &#x27;300&#x27;: &#x27;#dce775&#x27;,
    &#x27;400&#x27;: &#x27;#d4e157&#x27;,
    &#x27;500&#x27;: &#x27;#cddc39&#x27;,
    &#x27;600&#x27;: &#x27;#c0ca33&#x27;,
    &#x27;700&#x27;: &#x27;#afb42b&#x27;,
    &#x27;800&#x27;: &#x27;#9e9d24&#x27;,
    &#x27;900&#x27;: &#x27;#827717&#x27;,
    &#x27;A100&#x27;: &#x27;#f4ff81&#x27;,
    &#x27;A200&#x27;: &#x27;#eeff41&#x27;,
    &#x27;A400&#x27;: &#x27;#c6ff00&#x27;,
    &#x27;A700&#x27;: &#x27;#aeea00&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;900&#x27;
  },
  &#x27;yellow&#x27;: {
    &#x27;50&#x27;: &#x27;#fffde7&#x27;,
    &#x27;100&#x27;: &#x27;#fff9c4&#x27;,
    &#x27;200&#x27;: &#x27;#fff59d&#x27;,
    &#x27;300&#x27;: &#x27;#fff176&#x27;,
    &#x27;400&#x27;: &#x27;#ffee58&#x27;,
    &#x27;500&#x27;: &#x27;#ffeb3b&#x27;,
    &#x27;600&#x27;: &#x27;#fdd835&#x27;,
    &#x27;700&#x27;: &#x27;#fbc02d&#x27;,
    &#x27;800&#x27;: &#x27;#f9a825&#x27;,
    &#x27;900&#x27;: &#x27;#f57f17&#x27;,
    &#x27;A100&#x27;: &#x27;#ffff8d&#x27;,
    &#x27;A200&#x27;: &#x27;#ffff00&#x27;,
    &#x27;A400&#x27;: &#x27;#ffea00&#x27;,
    &#x27;A700&#x27;: &#x27;#ffd600&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;
  },
  &#x27;amber&#x27;: {
    &#x27;50&#x27;: &#x27;#fff8e1&#x27;,
    &#x27;100&#x27;: &#x27;#ffecb3&#x27;,
    &#x27;200&#x27;: &#x27;#ffe082&#x27;,
    &#x27;300&#x27;: &#x27;#ffd54f&#x27;,
    &#x27;400&#x27;: &#x27;#ffca28&#x27;,
    &#x27;500&#x27;: &#x27;#ffc107&#x27;,
    &#x27;600&#x27;: &#x27;#ffb300&#x27;,
    &#x27;700&#x27;: &#x27;#ffa000&#x27;,
    &#x27;800&#x27;: &#x27;#ff8f00&#x27;,
    &#x27;900&#x27;: &#x27;#ff6f00&#x27;,
    &#x27;A100&#x27;: &#x27;#ffe57f&#x27;,
    &#x27;A200&#x27;: &#x27;#ffd740&#x27;,
    &#x27;A400&#x27;: &#x27;#ffc400&#x27;,
    &#x27;A700&#x27;: &#x27;#ffab00&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;
  },
  &#x27;orange&#x27;: {
    &#x27;50&#x27;: &#x27;#fff3e0&#x27;,
    &#x27;100&#x27;: &#x27;#ffe0b2&#x27;,
    &#x27;200&#x27;: &#x27;#ffcc80&#x27;,
    &#x27;300&#x27;: &#x27;#ffb74d&#x27;,
    &#x27;400&#x27;: &#x27;#ffa726&#x27;,
    &#x27;500&#x27;: &#x27;#ff9800&#x27;,
    &#x27;600&#x27;: &#x27;#fb8c00&#x27;,
    &#x27;700&#x27;: &#x27;#f57c00&#x27;,
    &#x27;800&#x27;: &#x27;#ef6c00&#x27;,
    &#x27;900&#x27;: &#x27;#e65100&#x27;,
    &#x27;A100&#x27;: &#x27;#ffd180&#x27;,
    &#x27;A200&#x27;: &#x27;#ffab40&#x27;,
    &#x27;A400&#x27;: &#x27;#ff9100&#x27;,
    &#x27;A700&#x27;: &#x27;#ff6d00&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;800 900&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;800 900&#x27;
  },
  &#x27;deep-orange&#x27;: {
    &#x27;50&#x27;: &#x27;#fbe9e7&#x27;,
    &#x27;100&#x27;: &#x27;#ffccbc&#x27;,
    &#x27;200&#x27;: &#x27;#ffab91&#x27;,
    &#x27;300&#x27;: &#x27;#ff8a65&#x27;,
    &#x27;400&#x27;: &#x27;#ff7043&#x27;,
    &#x27;500&#x27;: &#x27;#ff5722&#x27;,
    &#x27;600&#x27;: &#x27;#f4511e&#x27;,
    &#x27;700&#x27;: &#x27;#e64a19&#x27;,
    &#x27;800&#x27;: &#x27;#d84315&#x27;,
    &#x27;900&#x27;: &#x27;#bf360c&#x27;,
    &#x27;A100&#x27;: &#x27;#ff9e80&#x27;,
    &#x27;A200&#x27;: &#x27;#ff6e40&#x27;,
    &#x27;A400&#x27;: &#x27;#ff3d00&#x27;,
    &#x27;A700&#x27;: &#x27;#dd2c00&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 300 400 A100 A200&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;500 600 700 800 900 A400 A700&#x27;
  },
  &#x27;brown&#x27;: {
    &#x27;50&#x27;: &#x27;#efebe9&#x27;,
    &#x27;100&#x27;: &#x27;#d7ccc8&#x27;,
    &#x27;200&#x27;: &#x27;#bcaaa4&#x27;,
    &#x27;300&#x27;: &#x27;#a1887f&#x27;,
    &#x27;400&#x27;: &#x27;#8d6e63&#x27;,
    &#x27;500&#x27;: &#x27;#795548&#x27;,
    &#x27;600&#x27;: &#x27;#6d4c41&#x27;,
    &#x27;700&#x27;: &#x27;#5d4037&#x27;,
    &#x27;800&#x27;: &#x27;#4e342e&#x27;,
    &#x27;900&#x27;: &#x27;#3e2723&#x27;,
    &#x27;A100&#x27;: &#x27;#d7ccc8&#x27;,
    &#x27;A200&#x27;: &#x27;#bcaaa4&#x27;,
    &#x27;A400&#x27;: &#x27;#8d6e63&#x27;,
    &#x27;A700&#x27;: &#x27;#5d4037&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;300 400&#x27;
  },
  &#x27;grey&#x27;: {
    &#x27;50&#x27;: &#x27;#fafafa&#x27;,
    &#x27;100&#x27;: &#x27;#f5f5f5&#x27;,
    &#x27;200&#x27;: &#x27;#eeeeee&#x27;,
    &#x27;300&#x27;: &#x27;#e0e0e0&#x27;,
    &#x27;400&#x27;: &#x27;#bdbdbd&#x27;,
    &#x27;500&#x27;: &#x27;#9e9e9e&#x27;,
    &#x27;600&#x27;: &#x27;#757575&#x27;,
    &#x27;700&#x27;: &#x27;#616161&#x27;,
    &#x27;800&#x27;: &#x27;#424242&#x27;,
    &#x27;900&#x27;: &#x27;#212121&#x27;,
    &#x27;1000&#x27;: &#x27;#000000&#x27;,
    &#x27;A100&#x27;: &#x27;#ffffff&#x27;,
    &#x27;A200&#x27;: &#x27;#eeeeee&#x27;,
    &#x27;A400&#x27;: &#x27;#bdbdbd&#x27;,
    &#x27;A700&#x27;: &#x27;#616161&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;dark&#x27;,
    &#x27;contrastLightColors&#x27;: &#x27;600 700 800 900&#x27;
  },
  &#x27;blue-grey&#x27;: {
    &#x27;50&#x27;: &#x27;#eceff1&#x27;,
    &#x27;100&#x27;: &#x27;#cfd8dc&#x27;,
    &#x27;200&#x27;: &#x27;#b0bec5&#x27;,
    &#x27;300&#x27;: &#x27;#90a4ae&#x27;,
    &#x27;400&#x27;: &#x27;#78909c&#x27;,
    &#x27;500&#x27;: &#x27;#607d8b&#x27;,
    &#x27;600&#x27;: &#x27;#546e7a&#x27;,
    &#x27;700&#x27;: &#x27;#455a64&#x27;,
    &#x27;800&#x27;: &#x27;#37474f&#x27;,
    &#x27;900&#x27;: &#x27;#263238&#x27;,
    &#x27;A100&#x27;: &#x27;#cfd8dc&#x27;,
    &#x27;A200&#x27;: &#x27;#b0bec5&#x27;,
    &#x27;A400&#x27;: &#x27;#78909c&#x27;,
    &#x27;A700&#x27;: &#x27;#455a64&#x27;,
    &#x27;contrastDefaultColor&#x27;: &#x27;light&#x27;,
    &#x27;contrastDarkColors&#x27;: &#x27;50 100 200 300&#x27;,
    &#x27;contrastStrongLightColors&#x27;: &#x27;400 500&#x27;
  }
});

angular.module(&#x27;material.core.theming&#x27;, [&#x27;material.core.theming.palette&#x27;])
  .directive(&#x27;mdTheme&#x27;, ThemingDirective)
  .directive(&#x27;mdThemable&#x27;, ThemableDirective)
  .provider(&#x27;$mdTheming&#x27;, ThemingProvider)
  .run(generateAllThemes);

/**
 * @ngdoc service
 * @name $mdThemingProvider
 * @module material.core.theming
 *
 * @description Provider to configure the &#x60;$mdTheming&#x60; service.
 */

/**
 * @ngdoc method
 * @name $mdThemingProvider#setNonce
 * @param {string} nonceValue The nonce to be added as an attribute to the theme style tags.
 * Setting a value allows the use CSP policy without using the unsafe-inline directive.
 */

/**
 * @ngdoc method
 * @name $mdThemingProvider#setDefaultTheme
 * @param {string} themeName Default theme name to be applied to elements. Default value is &#x60;default&#x60;.
 */

/**
 * @ngdoc method
 * @name $mdThemingProvider#alwaysWatchTheme
 * @param {boolean} watch Whether or not to always watch themes for changes and re-apply
 * classes when they change. Default is &#x60;false&#x60;. Enabling can reduce performance.
 */

/* Some Example Valid Theming Expressions
 * =======================================
 *
 * Intention group expansion: (valid for primary, accent, warn, background)
 *
 * {{primary-100}} - grab shade 100 from the primary palette
 * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7
 * {{primary-100-contrast}} - grab shade 100&#x27;s contrast color
 * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette
 * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1
 * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue
 * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules
 * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue
 * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules
 *
 * Foreground expansion: Applies rgba to black/white foreground text
 *
 * {{foreground-1}} - used for primary text
 * {{foreground-2}} - used for secondary text/divider
 * {{foreground-3}} - used for disabled text
 * {{foreground-4}} - used for dividers
 *
 */

// In memory generated CSS rules; registered by theme.name
var GENERATED = { };

// In memory storage of defined themes and color palettes (both loaded by CSS, and user specified)
var PALETTES;
var THEMES;

var DARK_FOREGROUND = {
  name: &#x27;dark&#x27;,
  &#x27;1&#x27;: &#x27;rgba(0,0,0,0.87)&#x27;,
  &#x27;2&#x27;: &#x27;rgba(0,0,0,0.54)&#x27;,
  &#x27;3&#x27;: &#x27;rgba(0,0,0,0.26)&#x27;,
  &#x27;4&#x27;: &#x27;rgba(0,0,0,0.12)&#x27;
};
var LIGHT_FOREGROUND = {
  name: &#x27;light&#x27;,
  &#x27;1&#x27;: &#x27;rgba(255,255,255,1.0)&#x27;,
  &#x27;2&#x27;: &#x27;rgba(255,255,255,0.7)&#x27;,
  &#x27;3&#x27;: &#x27;rgba(255,255,255,0.3)&#x27;,
  &#x27;4&#x27;: &#x27;rgba(255,255,255,0.12)&#x27;
};

var DARK_SHADOW = &#x27;1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)&#x27;;
var LIGHT_SHADOW = &#x27;&#x27;;

var DARK_CONTRAST_COLOR = colorToRgbaArray(&#x27;rgba(0,0,0,0.87)&#x27;);
var LIGHT_CONTRAST_COLOR = colorToRgbaArray(&#x27;rgba(255,255,255,0.87)&#x27;);
var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray(&#x27;rgb(255,255,255)&#x27;);

var THEME_COLOR_TYPES = [&#x27;primary&#x27;, &#x27;accent&#x27;, &#x27;warn&#x27;, &#x27;background&#x27;];
var DEFAULT_COLOR_TYPE = &#x27;primary&#x27;;

// A color in a theme will use these hues by default, if not specified by user.
var LIGHT_DEFAULT_HUES = {
  &#x27;accent&#x27;: {
    &#x27;default&#x27;: &#x27;A200&#x27;,
    &#x27;hue-1&#x27;: &#x27;A100&#x27;,
    &#x27;hue-2&#x27;: &#x27;A400&#x27;,
    &#x27;hue-3&#x27;: &#x27;A700&#x27;
  },
  &#x27;background&#x27;: {
    &#x27;default&#x27;: &#x27;A100&#x27;,
    &#x27;hue-1&#x27;: &#x27;300&#x27;,
    &#x27;hue-2&#x27;: &#x27;800&#x27;,
    &#x27;hue-3&#x27;: &#x27;900&#x27;
  }
};

var DARK_DEFAULT_HUES = {
  &#x27;background&#x27;: {
    &#x27;default&#x27;: &#x27;800&#x27;,
    &#x27;hue-1&#x27;: &#x27;600&#x27;,
    &#x27;hue-2&#x27;: &#x27;300&#x27;,
    &#x27;hue-3&#x27;: &#x27;900&#x27;
  }
};
THEME_COLOR_TYPES.forEach(function(colorType) {
  // Color types with unspecified default hues will use these default hue values
  var defaultDefaultHues = {
    &#x27;default&#x27;: &#x27;500&#x27;,
    &#x27;hue-1&#x27;: &#x27;300&#x27;,
    &#x27;hue-2&#x27;: &#x27;800&#x27;,
    &#x27;hue-3&#x27;: &#x27;A100&#x27;
  };
  if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
  if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
});

var VALID_HUE_VALUES = [
  &#x27;50&#x27;, &#x27;100&#x27;, &#x27;200&#x27;, &#x27;300&#x27;, &#x27;400&#x27;, &#x27;500&#x27;, &#x27;600&#x27;,
  &#x27;700&#x27;, &#x27;800&#x27;, &#x27;900&#x27;, &#x27;A100&#x27;, &#x27;A200&#x27;, &#x27;A400&#x27;, &#x27;A700&#x27;
];

// Whether or not themes are to be generated on-demand (vs. eagerly).
var generateOnDemand = false;

// Nonce to be added as an attribute to the generated themes style tags.
var nonce = null;

function ThemingProvider($mdColorPalette) {
  PALETTES = { };
  THEMES = { };

  var themingProvider;
  var defaultTheme = &#x27;default&#x27;;
  var alwaysWatchTheme = false;

  // Load JS Defined Palettes
  angular.extend(PALETTES, $mdColorPalette);

  // Default theme defined in core.js

  ThemingService.$inject = [&quot;$rootScope&quot;, &quot;$log&quot;];
  return themingProvider = {
    definePalette: definePalette,
    extendPalette: extendPalette,
    theme: registerTheme,

    setNonce: function(nonceValue) {
      nonce = nonceValue;
    },
    setDefaultTheme: function(theme) {
      defaultTheme = theme;
    },
    alwaysWatchTheme: function(alwaysWatch) {
      alwaysWatchTheme = alwaysWatch;
    },
    generateThemesOnDemand: function(onDemand) {
      generateOnDemand = onDemand;
    },
    $get: ThemingService,
    _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
    _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
    _PALETTES: PALETTES,
    _THEMES: THEMES,
    _parseRules: parseRules,
    _rgba: rgba
  };

  // Example: $mdThemingProvider.definePalette(&#x27;neonRed&#x27;, { 50: &#x27;#f5fafa&#x27;, ... });
  function definePalette(name, map) {
    map = map || {};
    PALETTES[name] = checkPaletteValid(name, map);
    return themingProvider;
  }

  // Returns an new object which is a copy of a given palette &#x60;name&#x60; with variables from
  // &#x60;map&#x60; overwritten
  // Example: var neonRedMap = $mdThemingProvider.extendPalette(&#x27;red&#x27;, { 50: &#x27;#f5fafafa&#x27; });
  function extendPalette(name, map) {
    return checkPaletteValid(name,  angular.extend({}, PALETTES[name] || {}, map) );
  }

  // Make sure that palette has all required hues
  function checkPaletteValid(name, map) {
    var missingColors = VALID_HUE_VALUES.filter(function(field) {
      return !map[field];
    });
    if (missingColors.length) {
      throw new Error(&quot;Missing colors %1 in palette %2!&quot;
                      .replace(&#x27;%1&#x27;, missingColors.join(&#x27;, &#x27;))
                      .replace(&#x27;%2&#x27;, name));
    }

    return map;
  }

  // Register a theme (which is a collection of color palettes to use with various states
  // ie. warn, accent, primary )
  // Optionally inherit from an existing theme
  // $mdThemingProvider.theme(&#x27;custom-theme&#x27;).primaryPalette(&#x27;red&#x27;);
  function registerTheme(name, inheritFrom) {
    if (THEMES[name]) return THEMES[name];

    inheritFrom = inheritFrom || &#x27;default&#x27;;

    var parentTheme = typeof inheritFrom === &#x27;string&#x27; ? THEMES[inheritFrom] : inheritFrom;
    var theme = new Theme(name);

    if (parentTheme) {
      angular.forEach(parentTheme.colors, function(color, colorType) {
        theme.colors[colorType] = {
          name: color.name,
          // Make sure a COPY of the hues is given to the child color,
          // not the same reference.
          hues: angular.extend({}, color.hues)
        };
      });
    }
    THEMES[name] = theme;

    return theme;
  }

  function Theme(name) {
    var self = this;
    self.name = name;
    self.colors = {};

    self.dark = setDark;
    setDark(false);

    function setDark(isDark) {
      isDark = arguments.length === 0 ? true : !!isDark;

      // If no change, abort
      if (isDark === self.isDark) return;

      self.isDark = isDark;

      self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
      self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;

      // Light and dark themes have different default hues.
      // Go through each existing color type for this theme, and for every
      // hue value that is still the default hue value from the previous light/dark setting,
      // set it to the default hue value from the new light/dark setting.
      var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
      var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
      angular.forEach(newDefaultHues, function(newDefaults, colorType) {
        var color = self.colors[colorType];
        var oldDefaults = oldDefaultHues[colorType];
        if (color) {
          for (var hueName in color.hues) {
            if (color.hues[hueName] === oldDefaults[hueName]) {
              color.hues[hueName] = newDefaults[hueName];
            }
          }
        }
      });

      return self;
    }

    THEME_COLOR_TYPES.forEach(function(colorType) {
      var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
      self[colorType + &#x27;Palette&#x27;] = function setPaletteType(paletteName, hues) {
        var color = self.colors[colorType] = {
          name: paletteName,
          hues: angular.extend({}, defaultHues, hues)
        };

        Object.keys(color.hues).forEach(function(name) {
          if (!defaultHues[name]) {
            throw new Error(&quot;Invalid hue name &#x27;%1&#x27; in theme %2&#x27;s %3 color %4. Available hue names: %4&quot;
              .replace(&#x27;%1&#x27;, name)
              .replace(&#x27;%2&#x27;, self.name)
              .replace(&#x27;%3&#x27;, paletteName)
              .replace(&#x27;%4&#x27;, Object.keys(defaultHues).join(&#x27;, &#x27;))
            );
          }
        });
        Object.keys(color.hues).map(function(key) {
          return color.hues[key];
        }).forEach(function(hueValue) {
          if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
            throw new Error(&quot;Invalid hue value &#x27;%1&#x27; in theme %2&#x27;s %3 color %4. Available hue values: %5&quot;
              .replace(&#x27;%1&#x27;, hueValue)
              .replace(&#x27;%2&#x27;, self.name)
              .replace(&#x27;%3&#x27;, colorType)
              .replace(&#x27;%4&#x27;, paletteName)
              .replace(&#x27;%5&#x27;, VALID_HUE_VALUES.join(&#x27;, &#x27;))
            );
          }
        });
        return self;
      };

      self[colorType + &#x27;Color&#x27;] = function() {
        var args = Array.prototype.slice.call(arguments);
        console.warn(&#x27;$mdThemingProviderTheme.&#x27; + colorType + &#x27;Color() has been deprecated. &#x27; +
                     &#x27;Use $mdThemingProviderTheme.&#x27; + colorType + &#x27;Palette() instead.&#x27;);
        return self[colorType + &#x27;Palette&#x27;].apply(self, args);
      };
    });
  }

  /**
   * @ngdoc service
   * @name $mdTheming
   *
   * @description
   *
   * Service that makes an element apply theming related classes to itself.
   *
   * &#x60;&#x60;&#x60;js
   * app.directive(&#x27;myFancyDirective&#x27;, function($mdTheming) {
   *   return {
   *     restrict: &#x27;e&#x27;,
   *     link: function(scope, el, attrs) {
   *       $mdTheming(el);
   *     }
   *   };
   * });
   * &#x60;&#x60;&#x60;
   * @param {el=} element to apply theming to
   */
  /* ngInject */
  function ThemingService($rootScope, $log) {

    applyTheme.inherit = function(el, parent) {
      var ctrl = parent.controller(&#x27;mdTheme&#x27;);

      var attrThemeValue = el.attr(&#x27;md-theme-watch&#x27;);
      if ( (alwaysWatchTheme || angular.isDefined(attrThemeValue)) &amp;&amp; attrThemeValue != &#x27;false&#x27;) {
        var deregisterWatch = $rootScope.$watch(function() {
          return ctrl &amp;&amp; ctrl.$mdTheme || (defaultTheme == &#x27;default&#x27; ? &#x27;&#x27; : defaultTheme);
        }, changeTheme);
        el.on(&#x27;$destroy&#x27;, deregisterWatch);
      } else {
        var theme = ctrl &amp;&amp; ctrl.$mdTheme || (defaultTheme == &#x27;default&#x27; ? &#x27;&#x27; : defaultTheme);
        changeTheme(theme);
      }

      function changeTheme(theme) {
        if (!theme) return;
        if (!registered(theme)) {
          $log.warn(&#x27;Attempted to use unregistered theme \&#x27;&#x27; + theme + &#x27;\&#x27;. &#x27; +
                    &#x27;Register it with $mdThemingProvider.theme().&#x27;);
        }
        var oldTheme = el.data(&#x27;$mdThemeName&#x27;);
        if (oldTheme) el.removeClass(&#x27;md-&#x27; + oldTheme +&#x27;-theme&#x27;);
        el.addClass(&#x27;md-&#x27; + theme + &#x27;-theme&#x27;);
        el.data(&#x27;$mdThemeName&#x27;, theme);
        if (ctrl) {
          el.data(&#x27;$mdThemeController&#x27;, ctrl);
        }
      }
    };

    applyTheme.THEMES = angular.extend({}, THEMES);
    applyTheme.defaultTheme = function() { return defaultTheme; };
    applyTheme.registered = registered;
    applyTheme.generateTheme = function(name) { generateTheme(name, nonce); };

    return applyTheme;

    function registered(themeName) {
      if (themeName === undefined || themeName === &#x27;&#x27;) return true;
      return applyTheme.THEMES[themeName] !== undefined;
    }

    function applyTheme(scope, el) {
      // Allow us to be invoked via a linking function signature.
      if (el === undefined) {
        el = scope;
        scope = undefined;
      }
      if (scope === undefined) {
        scope = $rootScope;
      }
      applyTheme.inherit(el, el);
    }
  }
}
ThemingProvider.$inject = [&quot;$mdColorPalette&quot;];

function ThemingDirective($mdTheming, $interpolate, $log) {
  return {
    priority: 100,
    link: {
      pre: function(scope, el, attrs) {
        var ctrl = {
          $setTheme: function(theme) {
            if (!$mdTheming.registered(theme)) {
              $log.warn(&#x27;attempted to use unregistered theme \&#x27;&#x27; + theme + &#x27;\&#x27;&#x27;);
            }
            ctrl.$mdTheme = theme;
          }
        };
        el.data(&#x27;$mdThemeController&#x27;, ctrl);
        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
        attrs.$observe(&#x27;mdTheme&#x27;, ctrl.$setTheme);
      }
    }
  };
}
ThemingDirective.$inject = [&quot;$mdTheming&quot;, &quot;$interpolate&quot;, &quot;$log&quot;];

function ThemableDirective($mdTheming) {
  return $mdTheming;
}
ThemableDirective.$inject = [&quot;$mdTheming&quot;];

function parseRules(theme, colorType, rules) {
  checkValidPalette(theme, colorType);

  rules = rules.replace(/THEME_NAME/g, theme.name);
  var generatedRules = [];
  var color = theme.colors[colorType];

  var themeNameRegex = new RegExp(&#x27;.md-&#x27; + theme.name + &#x27;-theme&#x27;, &#x27;g&#x27;);
  // Matches &#x27;{{ primary-color }}&#x27;, etc
  var hueRegex = new RegExp(&#x27;(\&#x27;|&quot;)?{{\\s*(&#x27; + colorType + &#x27;)-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\&quot;|\&#x27;)?&#x27;,&#x27;g&#x27;);
  var simpleVariableRegex = /&#x27;?&quot;?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}&#x27;?&quot;?/g;
  var palette = PALETTES[color.name];

  // find and replace simple variables where we use a specific hue, not an entire palette
  // eg. &quot;{{primary-100}}&quot;
  //\(&#x27; + THEME_COLOR_TYPES.join(&#x27;\|&#x27;) + &#x27;\)&#x27;
  rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
    if (colorType === &#x27;foreground&#x27;) {
      if (hue == &#x27;shadow&#x27;) {
        return theme.foregroundShadow;
      } else {
        return theme.foregroundPalette[hue] || theme.foregroundPalette[&#x27;1&#x27;];
      }
    }
    if (hue.indexOf(&#x27;hue&#x27;) === 0) {
      hue = theme.colors[colorType].hues[hue];
    }
    return rgba( (PALETTES[ theme.colors[colorType].name ][hue] || &#x27;&#x27;)[contrast ? &#x27;contrast&#x27; : &#x27;value&#x27;], opacity );
  });

  // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)
  angular.forEach(color.hues, function(hueValue, hueName) {
    var newRule = rules
      .replace(hueRegex, function(match, _, colorType, hueType, opacity) {
        return rgba(palette[hueValue][hueType === &#x27;color&#x27; ? &#x27;value&#x27; : &#x27;contrast&#x27;], opacity);
      });
    if (hueName !== &#x27;default&#x27;) {
      newRule = newRule.replace(themeNameRegex, &#x27;.md-&#x27; + theme.name + &#x27;-theme.md-&#x27; + hueName);
    }

    // Don&#x27;t apply a selector rule to the default theme, making it easier to override
    // styles of the base-component
    if (theme.name == &#x27;default&#x27;) {
      var themeRuleRegex = /((?:(?:(?: |&gt;|\.|\w|-|:|\(|\)|\[|\]|&quot;|&#x27;|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |&gt;|\.|\w|-|:|\(|\)|\[|\]|&quot;|&#x27;|=)*)/g;
      newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
        return match + &#x27;, &#x27; + prefix + target + suffix;
      });
    }
    generatedRules.push(newRule);
  });

  return generatedRules;
}

var rulesByType = {};

// Generate our themes at run time given the state of THEMES and PALETTES
function generateAllThemes($injector) {
  var head = document.head;
  var firstChild = head ? head.firstElementChild : null;
  var themeCss = $injector.has(&#x27;$MD_THEME_CSS&#x27;) ? $injector.get(&#x27;$MD_THEME_CSS&#x27;) : &#x27;&#x27;;

  if ( !firstChild ) return;
  if (themeCss.length === 0) return; // no rules, so no point in running this expensive task

  // Expose contrast colors for palettes to ensure that text is always readable
  angular.forEach(PALETTES, sanitizePalette);

  // MD_THEME_CSS is a string generated by the build process that includes all the themable
  // components as templates

  // Break the CSS into individual rules
  var rules = themeCss
                  .split(/\}(?!(\}|&#x27;|&quot;|;))/)
                  .filter(function(rule) { return rule &amp;&amp; rule.length; })
                  .map(function(rule) { return rule.trim() + &#x27;}&#x27;; });


  var ruleMatchRegex = new RegExp(&#x27;md-(&#x27; + THEME_COLOR_TYPES.join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;g&#x27;);

  THEME_COLOR_TYPES.forEach(function(type) {
    rulesByType[type] = &#x27;&#x27;;
  });


  // Sort the rules based on type, allowing us to do color substitution on a per-type basis
  rules.forEach(function(rule) {
    var match = rule.match(ruleMatchRegex);
    // First: test that if the rule has &#x27;.md-accent&#x27;, it goes into the accent set of rules
    for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {
      if (rule.indexOf(&#x27;.md-&#x27; + type) &gt; -1) {
        return rulesByType[type] += rule;
      }
    }

    // If no eg &#x27;md-accent&#x27; class is found, try to just find &#x27;accent&#x27; in the rule and guess from
    // there
    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
      if (rule.indexOf(type) &gt; -1) {
        return rulesByType[type] += rule;
      }
    }

    // Default to the primary array
    return rulesByType[DEFAULT_COLOR_TYPE] += rule;
  });

  // If themes are being generated on-demand, quit here. The user will later manually
  // call generateTheme to do this on a theme-by-theme basis.
  if (generateOnDemand) return;

  angular.forEach(THEMES, function(theme) {
    if (!GENERATED[theme.name]) {
      generateTheme(theme.name, nonce);
    }
  });


  // *************************
  // Internal functions
  // *************************

  // The user specifies a &#x27;default&#x27; contrast color as either light or dark,
  // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)
  function sanitizePalette(palette) {
    var defaultContrast = palette.contrastDefaultColor;
    var lightColors = palette.contrastLightColors || [];
    var strongLightColors = palette.contrastStrongLightColors || [];
    var darkColors = palette.contrastDarkColors || [];

    // These colors are provided as space-separated lists
    if (typeof lightColors === &#x27;string&#x27;) lightColors = lightColors.split(&#x27; &#x27;);
    if (typeof strongLightColors === &#x27;string&#x27;) strongLightColors = strongLightColors.split(&#x27; &#x27;);
    if (typeof darkColors === &#x27;string&#x27;) darkColors = darkColors.split(&#x27; &#x27;);

    // Cleanup after ourselves
    delete palette.contrastDefaultColor;
    delete palette.contrastLightColors;
    delete palette.contrastStrongLightColors;
    delete palette.contrastDarkColors;

    // Change { &#x27;A100&#x27;: &#x27;#fffeee&#x27; } to { &#x27;A100&#x27;: { value: &#x27;#fffeee&#x27;, contrast:DARK_CONTRAST_COLOR }
    angular.forEach(palette, function(hueValue, hueName) {
      if (angular.isObject(hueValue)) return; // Already converted
      // Map everything to rgb colors
      var rgbValue = colorToRgbaArray(hueValue);
      if (!rgbValue) {
        throw new Error(&quot;Color %1, in palette %2&#x27;s hue %3, is invalid. Hex or rgb(a) color expected.&quot;
                        .replace(&#x27;%1&#x27;, hueValue)
                        .replace(&#x27;%2&#x27;, palette.name)
                        .replace(&#x27;%3&#x27;, hueName));
      }

      palette[hueName] = {
        value: rgbValue,
        contrast: getContrastColor()
      };
      function getContrastColor() {
        if (defaultContrast === &#x27;light&#x27;) {
          if (darkColors.indexOf(hueName) &gt; -1) {
            return DARK_CONTRAST_COLOR;
          } else {
            return strongLightColors.indexOf(hueName) &gt; -1 ? STRONG_LIGHT_CONTRAST_COLOR
              : LIGHT_CONTRAST_COLOR;
          }
        } else {
          if (lightColors.indexOf(hueName) &gt; -1) {
            return strongLightColors.indexOf(hueName) &gt; -1 ? STRONG_LIGHT_CONTRAST_COLOR
              : LIGHT_CONTRAST_COLOR;
          } else {
            return DARK_CONTRAST_COLOR;
          }
        }
      }
    });
  }
}
generateAllThemes.$inject = [&quot;$injector&quot;];

function generateTheme(name, nonce) {
  var theme = THEMES[name];
  var head = document.head;
  var firstChild = head ? head.firstElementChild : null;

  if (!GENERATED[name]) {
    // For each theme, use the color palettes specified for
    // &#x60;primary&#x60;, &#x60;warn&#x60; and &#x60;accent&#x60; to generate CSS rules.
    THEME_COLOR_TYPES.forEach(function(colorType) {
      var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
      while (styleStrings.length) {
        var styleContent = styleStrings.shift();
        if (styleContent) {
          var style = document.createElement(&#x27;style&#x27;);
          style.setAttribute(&#x27;md-theme-style&#x27;, &#x27;&#x27;);
          if (nonce) {
            style.setAttribute(&#x27;nonce&#x27;, nonce);
          }
          style.appendChild(document.createTextNode(styleContent));
          head.insertBefore(style, firstChild);
        }
      }
    });


    if (theme.colors.primary.name == theme.colors.accent.name) {
      console.warn(&#x27;$mdThemingProvider: Using the same palette for primary and&#x27; +
                   &#x27; accent. This violates the material design spec.&#x27;);
    }

    GENERATED[theme.name] = true;
  }

}


function checkValidPalette(theme, colorType) {
  // If theme attempts to use a palette that doesnt exist, throw error
  if (!PALETTES[ (theme.colors[colorType] || {}).name ]) {
    throw new Error(
      &quot;You supplied an invalid color palette for theme %1&#x27;s %2 palette. Available palettes: %3&quot;
                    .replace(&#x27;%1&#x27;, theme.name)
                    .replace(&#x27;%2&#x27;, colorType)
                    .replace(&#x27;%3&#x27;, Object.keys(PALETTES).join(&#x27;, &#x27;))
    );
  }
}

function colorToRgbaArray(clr) {
  if (angular.isArray(clr) &amp;&amp; clr.length == 3) return clr;
  if (/^rgb/.test(clr)) {
    return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, &#x27;&#x27;).split(&#x27;,&#x27;).map(function(value, i) {
      return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
    });
  }
  if (clr.charAt(0) == &#x27;#&#x27;) clr = clr.substring(1);
  if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;

  var dig = clr.length / 3;
  var red = clr.substr(0, dig);
  var grn = clr.substr(dig, dig);
  var blu = clr.substr(dig * 2);
  if (dig === 1) {
    red += red;
    grn += grn;
    blu += blu;
  }
  return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
}

function rgba(rgbArray, opacity) {
  if ( !rgbArray ) return &quot;rgb(&#x27;0,0,0&#x27;)&quot;;

  if (rgbArray.length == 4) {
    rgbArray = angular.copy(rgbArray);
    opacity ? rgbArray.pop() : opacity = rgbArray.pop();
  }
  return opacity &amp;&amp; (typeof opacity == &#x27;number&#x27; || (typeof opacity == &#x27;string&#x27; &amp;&amp; opacity.length)) ?
    &#x27;rgba(&#x27; + rgbArray.join(&#x27;,&#x27;) + &#x27;,&#x27; + opacity + &#x27;)&#x27; :
    &#x27;rgb(&#x27; + rgbArray.join(&#x27;,&#x27;) + &#x27;)&#x27;;
}


(function() {
  &#x27;use strict&#x27;;

  /**
   * @ngdoc service
   * @name $mdButtonInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the default ripple configuration
   */

  angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdButtonInkRipple&#x27;, MdButtonInkRipple);

  function MdButtonInkRipple($mdInkRipple) {
    return {
      attach: function attachRipple(scope, element, options) {
        options = angular.extend(optionsForElement(element), options);

        return $mdInkRipple.attach(scope, element, options);
      }
    };

    function optionsForElement(element) {
      if (element.hasClass(&#x27;md-icon-button&#x27;)) {
        return {
          isMenuItem: element.hasClass(&#x27;md-menu-item&#x27;),
          fitRipple: true,
          center: true
        };
      } else {
        return {
          isMenuItem: element.hasClass(&#x27;md-menu-item&#x27;),
          dimBackground: true
        }
      }
    };
  }
  MdButtonInkRipple.$inject = [&quot;$mdInkRipple&quot;];;
})();

(function() {
  &#x27;use strict&#x27;;

    /**
   * @ngdoc service
   * @name $mdCheckboxInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdCheckboxInkRipple&#x27;, MdCheckboxInkRipple);

  function MdCheckboxInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: true,
        dimBackground: false,
        fitRipple: true
      }, options));
    };
  }
  MdCheckboxInkRipple.$inject = [&quot;$mdInkRipple&quot;];;
})();

(function() {
  &#x27;use strict&#x27;;

  /**
   * @ngdoc service
   * @name $mdListInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdListInkRipple&#x27;, MdListInkRipple);

  function MdListInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: false,
        dimBackground: true,
        outline: false,
        rippleSize: &#x27;full&#x27;
      }, options));
    };
  }
  MdListInkRipple.$inject = [&quot;$mdInkRipple&quot;];;
})();

/**
 * @ngdoc module
 * @name material.core.ripple
 * @description
 * Ripple
 */
angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdInkRipple&#x27;, InkRippleService)
    .directive(&#x27;mdInkRipple&#x27;, InkRippleDirective)
    .directive(&#x27;mdNoInk&#x27;, attrNoDirective)
    .directive(&#x27;mdNoBar&#x27;, attrNoDirective)
    .directive(&#x27;mdNoStretch&#x27;, attrNoDirective);

var DURATION = 450;

/**
 * @ngdoc directive
 * @name mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * The &#x60;md-ink-ripple&#x60; directive allows you to specify the ripple color or id a ripple is allowed.
 *
 * @param {string|boolean} md-ink-ripple A color string &#x60;#FF0000&#x60; or boolean (&#x60;false&#x60; or &#x60;0&#x60;) for preventing ripple
 *
 * @usage
 * ### String values
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;ANY md-ink-ripple=&quot;#FF0000&quot;&gt;
 *     Ripples in red
 *   &lt;/ANY&gt;
 *
 *   &lt;ANY md-ink-ripple=&quot;false&quot;&gt;
 *     Not rippling
 *   &lt;/ANY&gt;
 * &lt;/hljs&gt;
 *
 * ### Interpolated values
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;ANY md-ink-ripple=&quot;{{ randomColor() }}&quot;&gt;
 *     Ripples with the return value of &#x27;randomColor&#x27; function
 *   &lt;/ANY&gt;
 *
 *   &lt;ANY md-ink-ripple=&quot;{{ canRipple() }}&quot;&gt;
 *     Ripples if &#x27;canRipple&#x27; function return value is not &#x27;false&#x27; or &#x27;0&#x27;
 *   &lt;/ANY&gt;
 * &lt;/hljs&gt;
 */
function InkRippleDirective ($mdButtonInkRipple, $mdCheckboxInkRipple) {
  return {
    controller: angular.noop,
    link:       function (scope, element, attr) {
      attr.hasOwnProperty(&#x27;mdInkRippleCheckbox&#x27;)
          ? $mdCheckboxInkRipple.attach(scope, element)
          : $mdButtonInkRipple.attach(scope, element);
    }
  };
}
InkRippleDirective.$inject = [&quot;$mdButtonInkRipple&quot;, &quot;$mdCheckboxInkRipple&quot;];

/**
 * @ngdoc service
 * @name $mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * &#x60;$mdInkRipple&#x60; is a service for adding ripples to any element
 *
 * @usage
 * &lt;hljs lang=&quot;js&quot;&gt;
 * app.factory(&#x27;$myElementInkRipple&#x27;, function($mdInkRipple) {
 *   return {
 *     attach: function (scope, element, options) {
 *       return $mdInkRipple.attach(scope, element, angular.extend({
 *         center: false,
 *         dimBackground: true
 *       }, options));
 *     }
 *   };
 * });
 *
 * app.controller(&#x27;myController&#x27;, function ($scope, $element, $myElementInkRipple) {
 *   $scope.onClick = function (ev) {
 *     $myElementInkRipple.attach($scope, angular.element(ev.target), { center: true });
 *   }
 * });
 * &lt;/hljs&gt;
 */

/**
 * @ngdoc method
 * @name $mdInkRipple#attach
 *
 * @description
 * Attaching given scope, element and options to inkRipple controller
 *
 * @param {object=} scope Scope within the current context
 * @param {object=} element The element the ripple effect should be applied to
 * @param {object=} options (Optional) Configuration options to override the defaultRipple configuration
 * * &#x60;center&#x60; -  Whether the ripple should start from the center of the container element
 * * &#x60;dimBackground&#x60; - Whether the background should be dimmed with the ripple color
 * * &#x60;colorElement&#x60; - The element the ripple should take its color from, defined by css property &#x60;color&#x60;
 * * &#x60;fitRipple&#x60; - Whether the ripple should fill the element
 */
function InkRippleService ($injector) {
  return { attach: attach };
  function attach (scope, element, options) {
    if (element.controller(&#x27;mdNoInk&#x27;)) return angular.noop;
    return $injector.instantiate(InkRippleCtrl, {
      $scope:        scope,
      $element:      element,
      rippleOptions: options
    });
  }
}
InkRippleService.$inject = [&quot;$injector&quot;];

/**
 * Controller used by the ripple service in order to apply ripples
 * ngInject
 */
function InkRippleCtrl ($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
  this.$window    = $window;
  this.$timeout   = $timeout;
  this.$mdUtil    = $mdUtil;
  this.$scope     = $scope;
  this.$element   = $element;
  this.options    = rippleOptions;
  this.mousedown  = false;
  this.ripples    = [];
  this.timeout    = null; // Stores a reference to the most-recent ripple timeout
  this.lastRipple = null;

  $mdUtil.valueOnUse(this, &#x27;container&#x27;, this.createContainer);

  this.$element.addClass(&#x27;md-ink-ripple&#x27;);

  // attach method for unit tests
  ($element.controller(&#x27;mdInkRipple&#x27;) || {}).createRipple = angular.bind(this, this.createRipple);
  ($element.controller(&#x27;mdInkRipple&#x27;) || {}).setColor = angular.bind(this, this.color);

  this.bindEvents();
}
InkRippleCtrl.$inject = [&quot;$scope&quot;, &quot;$element&quot;, &quot;rippleOptions&quot;, &quot;$window&quot;, &quot;$timeout&quot;, &quot;$mdUtil&quot;];


/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup or mouseleave event)
 */
function autoCleanup (self, cleanupFn) {

  if ( self.mousedown || self.lastRipple ) {
    self.mousedown = false;
    self.$mdUtil.nextTick( angular.bind(self, cleanupFn), false);
  }

}


/**
 * Returns the color that the ripple should be (either based on CSS or hard-coded)
 * @returns {string}
 */
InkRippleCtrl.prototype.color = function (value) {
  var self = this;

  // If assigning a color value, apply it to background and the ripple color
  if (angular.isDefined(value)) {
    self._color = self._parseColor(value);
  }

  // If color lookup, use assigned, defined, or inherited
  return self._color || self._parseColor( self.inkRipple() ) || self._parseColor( getElementColor() );

  /**
   * Finds the color element and returns its text color for use as default ripple color
   * @returns {string}
   */
  function getElementColor () {
    var items = self.options &amp;&amp; self.options.colorElement ? self.options.colorElement : [];
    var elem =  items.length ? items[ 0 ] : self.$element[ 0 ];

    return elem ? self.$window.getComputedStyle(elem).color : &#x27;rgb(0,0,0)&#x27;;
  }
};

/**
 * Updating the ripple colors based on the current inkRipple value
 * or the element&#x27;s computed style color
 */
InkRippleCtrl.prototype.calculateColor = function () {
  return this.color();
};


/**
 * Takes a string color and converts it to RGBA format
 * @param color {string}
 * @param [multiplier] {int}
 * @returns {string}
 */

InkRippleCtrl.prototype._parseColor = function parseColor (color, multiplier) {
  multiplier = multiplier || 1;

  if (!color) return;
  if (color.indexOf(&#x27;rgba&#x27;) === 0) return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + &#x27;)&#x27;);
  if (color.indexOf(&#x27;rgb&#x27;) === 0) return rgbToRGBA(color);
  if (color.indexOf(&#x27;#&#x27;) === 0) return hexToRGBA(color);

  /**
   * Converts hex value to RGBA string
   * @param color {string}
   * @returns {string}
   */
  function hexToRGBA (color) {
    var hex   = color[ 0 ] === &#x27;#&#x27; ? color.substr(1) : color,
      dig   = hex.length / 3,
      red   = hex.substr(0, dig),
      green = hex.substr(dig, dig),
      blue  = hex.substr(dig * 2);
    if (dig === 1) {
      red += red;
      green += green;
      blue += blue;
    }
    return &#x27;rgba(&#x27; + parseInt(red, 16) + &#x27;,&#x27; + parseInt(green, 16) + &#x27;,&#x27; + parseInt(blue, 16) + &#x27;,0.1)&#x27;;
  }

  /**
   * Converts an RGB color to RGBA
   * @param color {string}
   * @returns {string}
   */
  function rgbToRGBA (color) {
    return color.replace(&#x27;)&#x27;, &#x27;, 0.1)&#x27;).replace(&#x27;(&#x27;, &#x27;a(&#x27;);
  }

};

/**
 * Binds events to the root element for
 */
InkRippleCtrl.prototype.bindEvents = function () {
  this.$element.on(&#x27;mousedown&#x27;, angular.bind(this, this.handleMousedown));
  this.$element.on(&#x27;mouseup touchend&#x27;, angular.bind(this, this.handleMouseup));
  this.$element.on(&#x27;mouseleave&#x27;, angular.bind(this, this.handleMouseup));
  this.$element.on(&#x27;touchmove&#x27;, angular.bind(this, this.handleTouchmove));
};

/**
 * Create a new ripple on every mousedown event from the root element
 * @param event {MouseEvent}
 */
InkRippleCtrl.prototype.handleMousedown = function (event) {
  if ( this.mousedown ) return;

  // When jQuery is loaded, we have to get the original event
  if (event.hasOwnProperty(&#x27;originalEvent&#x27;)) event = event.originalEvent;
  this.mousedown = true;
  if (this.options.center) {
    this.createRipple(this.container.prop(&#x27;clientWidth&#x27;) / 2, this.container.prop(&#x27;clientWidth&#x27;) / 2);
  } else {

    // We need to calculate the relative coordinates if the target is a sublayer of the ripple element
    if (event.srcElement !== this.$element[0]) {
      var layerRect = this.$element[0].getBoundingClientRect();
      var layerX = event.clientX - layerRect.left;
      var layerY = event.clientY - layerRect.top;

      this.createRipple(layerX, layerY);
    } else {
      this.createRipple(event.offsetX, event.offsetY);
    }
  }
};

/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup, touchend or mouseleave event)
 */
InkRippleCtrl.prototype.handleMouseup = function () {
  autoCleanup(this, this.clearRipples);
};

/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (by
 * touchmove)
 */
InkRippleCtrl.prototype.handleTouchmove = function () {
  autoCleanup(this, this.deleteRipples);
};

/**
 * Cycles through all ripples and attempts to remove them.
 */
InkRippleCtrl.prototype.deleteRipples = function () {
  for (var i = 0; i &lt; this.ripples.length; i++) {
    this.ripples[ i ].remove();
  }
};

/**
 * Cycles through all ripples and attempts to remove them with fade.
 * Depending on logic within &#x60;fadeInComplete&#x60;, some removals will be postponed.
 */
InkRippleCtrl.prototype.clearRipples = function () {
  for (var i = 0; i &lt; this.ripples.length; i++) {
    this.fadeInComplete(this.ripples[ i ]);
  }
};

/**
 * Creates the ripple container element
 * @returns {*}
 */
InkRippleCtrl.prototype.createContainer = function () {
  var container = angular.element(&#x27;&lt;div class=&quot;md-ripple-container&quot;&gt;&lt;/div&gt;&#x27;);
  this.$element.append(container);
  return container;
};

InkRippleCtrl.prototype.clearTimeout = function () {
  if (this.timeout) {
    this.$timeout.cancel(this.timeout);
    this.timeout = null;
  }
};

InkRippleCtrl.prototype.isRippleAllowed = function () {
  var element = this.$element[0];
  do {
    if (!element.tagName || element.tagName === &#x27;BODY&#x27;) break;

    if (element &amp;&amp; angular.isFunction(element.hasAttribute)) {
      if (element.hasAttribute(&#x27;disabled&#x27;)) return false;
      if (this.inkRipple() === &#x27;false&#x27; || this.inkRipple() === &#x27;0&#x27;) return false;
    }

  } while (element = element.parentNode);
  return true;
};

/**
 * The attribute &#x60;md-ink-ripple&#x60; may be a static or interpolated
 * color value OR a boolean indicator (used to disable ripples)
 */
InkRippleCtrl.prototype.inkRipple = function () {
  return this.$element.attr(&#x27;md-ink-ripple&#x27;);
};

/**
 * Creates a new ripple and adds it to the container.  Also tracks ripple in &#x60;this.ripples&#x60;.
 * @param left
 * @param top
 */
InkRippleCtrl.prototype.createRipple = function (left, top) {
  if (!this.isRippleAllowed()) return;

  var ctrl        = this;
  var ripple      = angular.element(&#x27;&lt;div class=&quot;md-ripple&quot;&gt;&lt;/div&gt;&#x27;);
  var width       = this.$element.prop(&#x27;clientWidth&#x27;);
  var height      = this.$element.prop(&#x27;clientHeight&#x27;);
  var x           = Math.max(Math.abs(width - left), left) * 2;
  var y           = Math.max(Math.abs(height - top), top) * 2;
  var size        = getSize(this.options.fitRipple, x, y);
  var color       = this.calculateColor();

  ripple.css({
    left:            left + &#x27;px&#x27;,
    top:             top + &#x27;px&#x27;,
    background:      &#x27;black&#x27;,
    width:           size + &#x27;px&#x27;,
    height:          size + &#x27;px&#x27;,
    backgroundColor: rgbaToRGB(color),
    borderColor:     rgbaToRGB(color)
  });
  this.lastRipple = ripple;

  // we only want one timeout to be running at a time
  this.clearTimeout();
  this.timeout    = this.$timeout(function () {
    ctrl.clearTimeout();
    if (!ctrl.mousedown) ctrl.fadeInComplete(ripple);
  }, DURATION * 0.35, false);

  if (this.options.dimBackground) this.container.css({ backgroundColor: color });
  this.container.append(ripple);
  this.ripples.push(ripple);
  ripple.addClass(&#x27;md-ripple-placed&#x27;);

  this.$mdUtil.nextTick(function () {

    ripple.addClass(&#x27;md-ripple-scaled md-ripple-active&#x27;);
    ctrl.$timeout(function () {
      ctrl.clearRipples();
    }, DURATION, false);

  }, false);

  function rgbaToRGB (color) {
    return color
        ? color.replace(&#x27;rgba&#x27;, &#x27;rgb&#x27;).replace(/,[^\),]+\)/, &#x27;)&#x27;)
        : &#x27;rgb(0,0,0)&#x27;;
  }

  function getSize (fit, x, y) {
    return fit
        ? Math.max(x, y)
        : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }
};



/**
 * After fadeIn finishes, either kicks off the fade-out animation or queues the element for removal on mouseup
 * @param ripple
 */
InkRippleCtrl.prototype.fadeInComplete = function (ripple) {
  if (this.lastRipple === ripple) {
    if (!this.timeout &amp;&amp; !this.mousedown) {
      this.removeRipple(ripple);
    }
  } else {
    this.removeRipple(ripple);
  }
};

/**
 * Kicks off the animation for removing a ripple
 * @param ripple {Element}
 */
InkRippleCtrl.prototype.removeRipple = function (ripple) {
  var ctrl  = this;
  var index = this.ripples.indexOf(ripple);
  if (index &lt; 0) return;
  this.ripples.splice(this.ripples.indexOf(ripple), 1);
  ripple.removeClass(&#x27;md-ripple-active&#x27;);
  if (this.ripples.length === 0) this.container.css({ backgroundColor: &#x27;&#x27; });
  // use a 2-second timeout in order to allow for the animation to finish
  // we don&#x27;t actually care how long the animation takes
  this.$timeout(function () {
    ctrl.fadeOutComplete(ripple);
  }, DURATION, false);
};

/**
 * Removes the provided ripple from the DOM
 * @param ripple
 */
InkRippleCtrl.prototype.fadeOutComplete = function (ripple) {
  ripple.remove();
  this.lastRipple = null;
};

/**
 * Used to create an empty directive.  This is used to track flag-directives whose children may have
 * functionality based on them.
 *
 * Example: &#x60;md-no-ink&#x60; will potentially be used by all child directives.
 */
function attrNoDirective () {
  return { controller: angular.noop };
}

(function() {
  &#x27;use strict&#x27;;

    /**
   * @ngdoc service
   * @name $mdTabInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  angular.module(&#x27;material.core&#x27;)
    .factory(&#x27;$mdTabInkRipple&#x27;, MdTabInkRipple);

  function MdTabInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: false,
        dimBackground: true,
        outline: false,
        rippleSize: &#x27;full&#x27;
      }, options));
    };
  }
  MdTabInkRipple.$inject = [&quot;$mdInkRipple&quot;];;
})();

// Polyfill angular &lt; 1.4 (provide $animateCss)
angular
  .module(&#x27;material.core&#x27;)
  .factory(&#x27;$$mdAnimate&#x27;, [&quot;$q&quot;, &quot;$timeout&quot;, &quot;$mdConstant&quot;, &quot;$animateCss&quot;, function($q, $timeout, $mdConstant, $animateCss){

     // Since $$mdAnimate is injected into $mdUtil... use a wrapper function
     // to subsequently inject $mdUtil as an argument to the AnimateDomUtils

     return function($mdUtil) {
       return AnimateDomUtils( $mdUtil, $q, $timeout, $mdConstant, $animateCss);
     };
   }]);

/**
 * Factory function that requires special injections
 */
function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
  var self;
  return self = {
    /**
     *
     */
    translate3d : function( target, from, to, options ) {
      return $animateCss(target,{
        from:from,
        to:to,
        addClass:options.transitionInClass
      })
      .start()
      .then(function(){
          // Resolve with reverser function...
          return reverseTranslate;
      });

      /**
       * Specific reversal of the request translate animation above...
       */
      function reverseTranslate (newFrom) {
        return $animateCss(target, {
           to: newFrom || from,
           addClass: options.transitionOutClass,
           removeClass: options.transitionInClass
        }).start();

      }
  },

    /**
     * Listen for transitionEnd event (with optional timeout)
     * Announce completion or failure via promise handlers
     */
    waitTransitionEnd: function (element, opts) {
        var TIMEOUT = 3000; // fallback is 3 secs

        return $q(function(resolve, reject){
          opts = opts || { };

          var timer = $timeout(finished, opts.timeout || TIMEOUT);
          element.on($mdConstant.CSS.TRANSITIONEND, finished);

          /**
           * Upon timeout or transitionEnd, reject or resolve (respectively) this promise.
           * NOTE: Make sure this transitionEnd didn&#x27;t bubble up from a child
           */
          function finished(ev) {
            if ( ev &amp;&amp; ev.target !== element[0]) return;

            if ( ev  ) $timeout.cancel(timer);
            element.off($mdConstant.CSS.TRANSITIONEND, finished);

            // Never reject since ngAnimate may cause timeouts due missed transitionEnd events
            resolve();

          }

        });
      },

    /**
     * Calculate the zoom transform from dialog to origin.
     *
     * We use this to set the dialog position immediately;
     * then the md-transition-in actually translates back to
     * &#x60;translate3d(0,0,0) scale(1.0)&#x60;...
     *
     * NOTE: all values are rounded to the nearest integer
     */
    calculateZoomToOrigin: function (element, originator) {
      var origin = originator.element;
      var bounds = originator.bounds;

      var zoomTemplate = &quot;translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )&quot;;
      var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
      var zoomStyle = buildZoom({centerX: 0, centerY: 0, scaleX: 0.5, scaleY: 0.5});

      if (origin || bounds) {
        var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
        var dialogRect = self.copyRect(element[0].getBoundingClientRect());
        var dialogCenterPt = self.centerPointFor(dialogRect);
        var originCenterPt = self.centerPointFor(originBnds);

        // Build the transform to zoom from the dialog center to the origin center

        zoomStyle = buildZoom({
          centerX: originCenterPt.x - dialogCenterPt.x,
          centerY: originCenterPt.y - dialogCenterPt.y,
          scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width))/100,
          scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height))/100
        });
      }

      return zoomStyle;

      /**
       * This is a fallback if the origin information is no longer valid, then the
       * origin bounds simply becomes the current bounds for the dialogContainer&#x27;s parent
       */
      function currentBounds() {
        var cntr = element ? element.parent() : null;
        var parent = cntr ? cntr.parent() : null;

        return parent ? self.clientRect(parent) : null;
      }
    },

    /**
     * Enhance raw values to represent valid css stylings...
     */
    toCss : function( raw ) {
      var css = { };
      var lookups = &#x27;left top right bottom width height x y min-width min-height max-width max-height&#x27;;

      angular.forEach(raw, function(value,key) {
        if ( angular.isUndefined(value) ) return;

        if ( lookups.indexOf(key) &gt;= 0 ) {
          css[key] = value + &#x27;px&#x27;;
        } else {
          switch (key) {
            case &#x27;transition&#x27;:
              convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
              break;
            case &#x27;transform&#x27;:
              convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
              break;
            case &#x27;transformOrigin&#x27;:
              convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
              break;
          }
        }
      });

      return css;

      function convertToVendor(key, vendor, value) {
        angular.forEach(vendor.split(&#x27; &#x27;), function (key) {
          css[key] = value;
        });
      }
    },

    /**
     * Convert the translate CSS value to key/value pair(s).
     */
    toTransformCss: function (transform, addTransition, transition) {
      var css = {};
      angular.forEach($mdConstant.CSS.TRANSFORM.split(&#x27; &#x27;), function (key) {
        css[key] = transform;
      });

      if (addTransition) {
        transition = transition || &quot;all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important&quot;;
        css[&#x27;transition&#x27;] = transition;
      }

      return css;
    },

    /**
     *  Clone the Rect and calculate the height/width if needed
     */
    copyRect: function (source, destination) {
      if (!source) return null;

      destination = destination || {};

      angular.forEach(&#x27;left top right bottom width height&#x27;.split(&#x27; &#x27;), function (key) {
        destination[key] = Math.round(source[key])
      });

      destination.width = destination.width || (destination.right - destination.left);
      destination.height = destination.height || (destination.bottom - destination.top);

      return destination;
    },

    /**
     * Calculate ClientRect of element; return null if hidden or zero size
     */
    clientRect: function (element) {
      var bounds = angular.element(element)[0].getBoundingClientRect();
      var isPositiveSizeClientRect = function (rect) {
        return rect &amp;&amp; (rect.width &gt; 0) &amp;&amp; (rect.height &gt; 0);
      };

      // If the event origin element has zero size, it has probably been hidden.
      return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
    },

    /**
     *  Calculate &#x27;rounded&#x27; center point of Rect
     */
    centerPointFor: function (targetRect) {
      return targetRect ? {
        x: Math.round(targetRect.left + (targetRect.width / 2)),
        y: Math.round(targetRect.top + (targetRect.height / 2))
      } : { x : 0, y : 0 };
    }

  };
};


&quot;use strict&quot;;

if (angular.version.minor &gt;= 4) {
  angular.module(&#x27;material.core.animate&#x27;, []);
} else {
(function() {

  var forEach = angular.forEach;

  var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
  var TRANSITION_PROP = WEBKIT ? &#x27;WebkitTransition&#x27; : &#x27;transition&#x27;;
  var ANIMATION_PROP = WEBKIT ? &#x27;WebkitAnimation&#x27; : &#x27;animation&#x27;;
  var PREFIX = WEBKIT ? &#x27;-webkit-&#x27; : &#x27;&#x27;;

  var TRANSITION_EVENTS = (WEBKIT ? &#x27;webkitTransitionEnd &#x27; : &#x27;&#x27;) + &#x27;transitionend&#x27;;
  var ANIMATION_EVENTS = (WEBKIT ? &#x27;webkitAnimationEnd &#x27; : &#x27;&#x27;) + &#x27;animationend&#x27;;

  var $$ForceReflowFactory = [&#x27;$document&#x27;, function($document) {
    return function() {
      return $document[0].body.clientWidth + 1;
    }
  }];

  var $$rAFMutexFactory = [&#x27;$$rAF&#x27;, function($$rAF) {
    return function() {
      var passed = false;
      $$rAF(function() {
        passed = true;
      });
      return function(fn) {
        passed ? fn() : $$rAF(fn);
      };
    };
  }];

  var $$AnimateRunnerFactory = [&#x27;$q&#x27;, &#x27;$$rAFMutex&#x27;, function($q, $$rAFMutex) {
    var INITIAL_STATE = 0;
    var DONE_PENDING_STATE = 1;
    var DONE_COMPLETE_STATE = 2;

    function AnimateRunner(host) {
      this.setHost(host);

      this._doneCallbacks = [];
      this._runInAnimationFrame = $$rAFMutex();
      this._state = 0;
    }

    AnimateRunner.prototype = {
      setHost: function(host) {
        this.host = host || {};
      },

      done: function(fn) {
        if (this._state === DONE_COMPLETE_STATE) {
          fn();
        } else {
          this._doneCallbacks.push(fn);
        }
      },

      progress: angular.noop,

      getPromise: function() {
        if (!this.promise) {
          var self = this;
          this.promise = $q(function(resolve, reject) {
            self.done(function(status) {
              status === false ? reject() : resolve();
            });
          });
        }
        return this.promise;
      },

      then: function(resolveHandler, rejectHandler) {
        return this.getPromise().then(resolveHandler, rejectHandler);
      },

      &#x27;catch&#x27;: function(handler) {
        return this.getPromise()[&#x27;catch&#x27;](handler);
      },

      &#x27;finally&#x27;: function(handler) {
        return this.getPromise()[&#x27;finally&#x27;](handler);
      },

      pause: function() {
        if (this.host.pause) {
          this.host.pause();
        }
      },

      resume: function() {
        if (this.host.resume) {
          this.host.resume();
        }
      },

      end: function() {
        if (this.host.end) {
          this.host.end();
        }
        this._resolve(true);
      },

      cancel: function() {
        if (this.host.cancel) {
          this.host.cancel();
        }
        this._resolve(false);
      },

      complete: function(response) {
        var self = this;
        if (self._state === INITIAL_STATE) {
          self._state = DONE_PENDING_STATE;
          self._runInAnimationFrame(function() {
            self._resolve(response);
          });
        }
      },

      _resolve: function(response) {
        if (this._state !== DONE_COMPLETE_STATE) {
          forEach(this._doneCallbacks, function(fn) {
            fn(response);
          });
          this._doneCallbacks.length = 0;
          this._state = DONE_COMPLETE_STATE;
        }
      }
    };

    return AnimateRunner;
  }];

  angular
    .module(&#x27;material.core.animate&#x27;, [])
    .factory(&#x27;$$forceReflow&#x27;, $$ForceReflowFactory)
    .factory(&#x27;$$AnimateRunner&#x27;, $$AnimateRunnerFactory)
    .factory(&#x27;$$rAFMutex&#x27;, $$rAFMutexFactory)
    .factory(&#x27;$animateCss&#x27;, [&#x27;$window&#x27;, &#x27;$$rAF&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$$forceReflow&#x27;, &#x27;$$jqLite&#x27;, &#x27;$timeout&#x27;,
                     function($window,   $$rAF,   $$AnimateRunner,   $$forceReflow,   $$jqLite,   $timeout) {

      function init(element, options) {

        var temporaryStyles = [];
        var node = getDomNode(element);

        if (options.transitionStyle) {
          temporaryStyles.push([PREFIX + &#x27;transition&#x27;, options.transitionStyle]);
        }

        if (options.keyframeStyle) {
          temporaryStyles.push([PREFIX + &#x27;animation&#x27;, options.keyframeStyle]);
        }

        if (options.delay) {
          temporaryStyles.push([PREFIX + &#x27;transition-delay&#x27;, options.delay + &#x27;s&#x27;]);
        }

        if (options.duration) {
          temporaryStyles.push([PREFIX + &#x27;transition-duration&#x27;, options.duration + &#x27;s&#x27;]);
        }

        var hasCompleteStyles = options.keyframeStyle ||
                                (options.to &amp;&amp; (options.duration &gt; 0 || options.transitionStyle));
        var hasCompleteClasses = !!options.addClass || !!options.removeClass;
        var hasCompleteAnimation = hasCompleteStyles || hasCompleteClasses;

        blockTransition(element, true);
        applyAnimationFromStyles(element, options);

        var animationClosed = false;
        var events, eventFn;

        return {
          close: $window.close,
          start: function() {
            var runner = new $$AnimateRunner();
            waitUntilQuiet(function() {
              blockTransition(element, false);
              if (!hasCompleteAnimation) {
                return close();
              }

              forEach(temporaryStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[camelCase(key)] = value;
              });

              applyClasses(element, options);

              var timings = computeTimings(element);
              if (timings.duration === 0) {
                return close();
              }

              var moreStyles = [];

              if (options.easing) {
                if (timings.transitionDuration) {
                  moreStyles.push([PREFIX + &#x27;transition-timing-function&#x27;, options.easing]);
                }
                if (timings.animationDuration) {
                  moreStyles.push([PREFIX + &#x27;animation-timing-function&#x27;, options.easing]);
                }
              }

              if (options.delay &amp;&amp; timings.animationDelay) {
                moreStyles.push([PREFIX + &#x27;animation-delay&#x27;, options.delay + &#x27;s&#x27;]);
              }

              if (options.duration &amp;&amp; timings.animationDuration) {
                moreStyles.push([PREFIX + &#x27;animation-duration&#x27;, options.duration + &#x27;s&#x27;]);
              }

              forEach(moreStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[camelCase(key)] = value;
                temporaryStyles.push(entry);
              });

              var maxDelay = timings.delay;
              var maxDelayTime = maxDelay * 1000;
              var maxDuration = timings.duration;
              var maxDurationTime = maxDuration * 1000;
              var startTime = Date.now();

              events = [];
              if (timings.transitionDuration) {
                events.push(TRANSITION_EVENTS);
              }
              if (timings.animationDuration) {
                events.push(ANIMATION_EVENTS);
              }
              events = events.join(&#x27; &#x27;);
              eventFn = function(event) {
                event.stopPropagation();
                var ev = event.originalEvent || event;
                var timeStamp = ev.timeStamp || Date.now();
                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                if (Math.max(timeStamp - startTime, 0) &gt;= maxDelayTime &amp;&amp; elapsedTime &gt;= maxDuration) {
                  close();
                }
              };
              element.on(events, eventFn);

              applyAnimationToStyles(element, options);

              $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
            });

            return runner;

            function close() {
              if (animationClosed) return;
              animationClosed = true;

              if (events &amp;&amp; eventFn) {
                element.off(events, eventFn);
              }
              applyClasses(element, options);
              applyAnimationStyles(element, options);
              forEach(temporaryStyles, function(entry) {
                node.style[camelCase(entry[0])] = &#x27;&#x27;;
              });
              runner.complete(true);
              return runner;
            }
          }
        }
      }

      function applyClasses(element, options) {
        if (options.addClass) {
          $$jqLite.addClass(element, options.addClass);
          options.addClass = null;
        }
        if (options.removeClass) {
          $$jqLite.removeClass(element, options.removeClass);
          options.removeClass = null;
        }
      }

      function computeTimings(element) {
        var node = getDomNode(element);
        var cs = $window.getComputedStyle(node)
        var tdr = parseMaxTime(cs[prop(&#x27;transitionDuration&#x27;)]);
        var adr = parseMaxTime(cs[prop(&#x27;animationDuration&#x27;)]);
        var tdy = parseMaxTime(cs[prop(&#x27;transitionDelay&#x27;)]);
        var ady = parseMaxTime(cs[prop(&#x27;animationDelay&#x27;)]);

        adr *= (parseInt(cs[prop(&#x27;animationIterationCount&#x27;)], 10) || 1);
        var duration = Math.max(adr, tdr);
        var delay = Math.max(ady, tdy);

        return {
          duration: duration,
          delay: delay,
          animationDuration: adr,
          transitionDuration: tdr,
          animationDelay: ady,
          transitionDelay: tdy
        };

        function prop(key) {
          return WEBKIT ? &#x27;Webkit&#x27; + key.charAt(0).toUpperCase() + key.substr(1)
                        : key;
        }
      }

      function parseMaxTime(str) {
        var maxValue = 0;
        var values = (str || &quot;&quot;).split(/\s*,\s*/);
        forEach(values, function(value) {
          // it&#x27;s always safe to consider only second values and omit &#x60;ms&#x60; values since
          // getComputedStyle will always handle the conversion for us
          if (value.charAt(value.length - 1) == &#x27;s&#x27;) {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }

      var cancelLastRAFRequest;
      var rafWaitQueue = [];
      function waitUntilQuiet(callback) {
        if (cancelLastRAFRequest) {
          cancelLastRAFRequest(); //cancels the request
        }
        rafWaitQueue.push(callback);
        cancelLastRAFRequest = $$rAF(function() {
          cancelLastRAFRequest = null;

          // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE &#x60;pageWidth&#x60; variable.
          // PLEASE EXAMINE THE &#x60;$$forceReflow&#x60; service to understand why.
          var pageWidth = $$forceReflow();

          // we use a for loop to ensure that if the queue is changed
          // during this looping then it will consider new requests
          for (var i = 0; i &lt; rafWaitQueue.length; i++) {
            rafWaitQueue[i](pageWidth);
          }
          rafWaitQueue.length = 0;
        });
      }

      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }

      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }

      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }

      function getDomNode(element) {
        for (var i = 0; i &lt; element.length; i++) {
          if (element[i].nodeType === 1) return element[i];
        }
      }

      function blockTransition(element, bool) {
        var node = getDomNode(element);
        var key = camelCase(PREFIX + &#x27;transition-delay&#x27;);
        node.style[key] = bool ? &#x27;-9999s&#x27; : &#x27;&#x27;;
      }

      return init;
    }]);

  /**
   * Older browsers [FF31] expect camelCase
   * property keys.
   * e.g.
   *  animation-duration --&gt; animationDuration
   */
  function camelCase(str) {
    return str.replace(/-[a-z]/g, function(str) {
      return str.charAt(1).toUpperCase();
    });
  }

})();

}

(function(){ 
angular.module(&quot;material.core&quot;).constant(&quot;$MD_THEME_CSS&quot;, &quot;md-autocomplete.md-THEME_NAME-theme {  background: &#x27;{{background-50}}&#x27;; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: &#x27;{{background-100}}&#x27;; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: &#x27;{{background-600}}&#x27;; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: &#x27;{{background-600-0.3}}&#x27;; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: &#x27;{{background-50}}&#x27;; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: &#x27;{{background-900}}&#x27;; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: &#x27;{{background-600}}&#x27;; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: &#x27;{{background-200}}&#x27;; }md-backdrop {  background-color: &#x27;{{background-900-0.0}}&#x27;; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: &#x27;{{background-900-1.0}}&#x27;; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: &#x27;{{background-50}}&#x27;;  border-top-color: &#x27;{{background-300}}&#x27;; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: &#x27;{{foreground-1}}&#x27;; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: &#x27;{{background-50}}&#x27;; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: &#x27;{{foreground-1}}&#x27;; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: &#x27;{{background-500-0.2}}&#x27;; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: &#x27;{{background-500-0.2}}&#x27;; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: &#x27;{{accent-color}}&#x27;;  color: &#x27;{{accent-contrast}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: &#x27;{{accent-contrast}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: &#x27;{{accent-color}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: &#x27;{{accent-A700}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: &#x27;{{primary-color}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: &#x27;{{primary-contrast}}&#x27;;    background-color: &#x27;{{primary-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: &#x27;{{primary-contrast}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: &#x27;{{primary-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: &#x27;{{primary-600}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: &#x27;{{primary-color}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: &#x27;{{accent-color}}&#x27;;  color: &#x27;{{accent-contrast}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: &#x27;{{accent-contrast}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: &#x27;{{accent-color}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: &#x27;{{accent-A700}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: &#x27;{{background-900}}&#x27;;  background-color: &#x27;{{background-50}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: &#x27;{{background-900}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: &#x27;{{background-50}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: &#x27;{{background-200}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: &#x27;{{warn-color}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: &#x27;{{warn-contrast}}&#x27;;    background-color: &#x27;{{warn-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: &#x27;{{warn-contrast}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: &#x27;{{warn-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: &#x27;{{warn-700}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: &#x27;{{warn-color}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: &#x27;{{accent-color}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: &#x27;{{accent-contrast}}&#x27;;    background-color: &#x27;{{accent-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: &#x27;{{accent-contrast}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: &#x27;{{accent-color}}&#x27;; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: &#x27;{{accent-700}}&#x27;; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: &#x27;{{accent-color}}&#x27;; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: &#x27;{{foreground-3}}&#x27; !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: &#x27;{{foreground-3}}&#x27;; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: &#x27;{{foreground-4}}&#x27;; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: &#x27;{{accent-600}}&#x27;; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: &#x27;{{background-600}}&#x27;; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: &#x27;{{accent-color-0.26}}&#x27;; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: &#x27;{{accent-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: &#x27;{{accent-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: &#x27;{{accent-contrast-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: &#x27;{{primary-600}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: &#x27;{{background-600}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: &#x27;{{primary-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: &#x27;{{primary-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: &#x27;{{primary-color-0.26}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: &#x27;{{primary-contrast-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: &#x27;{{warn-600}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: &#x27;{{warn-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: &#x27;{{foreground-2}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: &#x27;{{warn-color-0.87}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: &#x27;{{warn-color-0.26}}&#x27;; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: &#x27;{{background-200}}&#x27;; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: &#x27;{{foreground-3}}&#x27;; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: &#x27;{{foreground-3}}&#x27;; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: &#x27;{{background-200}}&#x27;; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: &#x27;{{foreground-3}}&#x27;; }md-card.md-THEME_NAME-theme {  background-color: &#x27;{{background-color}}&#x27;;  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: &#x27;{{background-color}}&#x27;;    background-color: &#x27;{{foreground-3}}&#x27;; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: &#x27;{{foreground-2}}&#x27;; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: &#x27;{{foreground-2}}&#x27;; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px &#x27;{{background-300}}&#x27;; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px &#x27;{{primary-color}}&#x27;; }md-chips.md-THEME_NAME-theme .md-chip {  background: &#x27;{{background-300}}&#x27;;  color: &#x27;{{background-800}}&#x27;; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: &#x27;{{primary-color}}&#x27;;    color: &#x27;{{primary-contrast}}&#x27;; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: &#x27;{{primary-contrast}}&#x27;; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: &#x27;{{background-500}}&#x27;; }.md-contact-suggestion span.md-contact-email {  color: &#x27;{{background-400}}&#x27;; }md-content.md-THEME_NAME-theme {  color: &#x27;{{foreground-1}}&#x27;;  background-color: &#x27;{{background-color}}&#x27;; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: &#x27;{{foreground-1}}&#x27;; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: &#x27;{{background-200}}&#x27;; }.md-THEME_NAME-theme .md-calendar-day-header {  background: &#x27;{{background-hue-1}}&#x27;;  color: &#x27;{{foreground-1}}&#x27;; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid &#x27;{{primary-500}}&#x27;; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: &#x27;{{primary-500-0.6}}&#x27;; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: &#x27;{{background-hue-1}}&#x27;; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: &#x27;{{background-hue-1}}&#x27;; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: &#x27;{{primary-500}}&#x27;;  color: &#x27;{{primary-500-contrast}}&#x27;;  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: &#x27;{{foreground-3}}&#x27;; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: &#x27;{{background-color}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-input {  color: &#x27;{{background-contrast}}&#x27;;  background: &#x27;{{background-color}}&#x27;; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \&quot;{{foreground-3}}\&quot;; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: &#x27;{{background-300}}&#x27;; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: &#x27;{{primary-500}}&#x27;; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: &#x27;{{warn-A700}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: &#x27;{{background-300}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: &#x27;{{foreground-3}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: &#x27;{{foreground-2}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: &#x27;{{primary-500}}&#x27;; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: &#x27;{{background-color}}&#x27;; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: &#x27;{{background-color}}&#x27;; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: &#x27;{{foreground-4}}&#x27;; }md-divider.md-THEME_NAME-theme {  border-top-color: &#x27;{{foreground-4}}&#x27;; }.layout-row &gt; md-divider.md-THEME_NAME-theme {  border-right-color: &#x27;{{foreground-4}}&#x27;; }md-icon.md-THEME_NAME-theme {  color: &#x27;{{foreground-2}}&#x27;; }  md-icon.md-THEME_NAME-theme.md-primary {    color: &#x27;{{primary-color}}&#x27;; }  md-icon.md-THEME_NAME-theme.md-accent {    color: &#x27;{{accent-color}}&#x27;; }  md-icon.md-THEME_NAME-theme.md-warn {    color: &#x27;{{warn-color}}&#x27;; }md-input-container.md-THEME_NAME-theme .md-input {  color: &#x27;{{foreground-1}}&#x27;;  border-color: &#x27;{{foreground-4}}&#x27;;  text-shadow: &#x27;{{foreground-shadow}}&#x27;; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \&quot;{{foreground-3}}\&quot;; }md-input-container.md-THEME_NAME-theme &gt; md-icon {  color: &#x27;{{foreground-1}}&#x27;; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: &#x27;{{foreground-shadow}}&#x27;;  color: &#x27;{{foreground-3}}&#x27;; }md-input-container.md-THEME_NAME-theme ng-messages :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [ng-messages] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme data-ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme x-ng-message :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message-exp] :not(.md-char-counter) {  color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: &#x27;{{foreground-2}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: &#x27;{{primary-500}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: &#x27;{{primary-500}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: &#x27;{{primary-500}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: &#x27;{{accent-500}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: &#x27;{{accent-500}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: &#x27;{{warn-A700}}&#x27;; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: &#x27;{{foreground-3}}&#x27;;  background-image: linear-gradient(to right, \&quot;{{foreground-3}}\&quot; 0%, \&quot;{{foreground-3}}\&quot; 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \&quot;{{foreground-3}}\&quot; 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: &#x27;{{foreground-1}}&#x27;; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: &#x27;{{foreground-2}}&#x27;; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: &#x27;{{background-100}}&#x27;; }md-list.md-THEME_NAME-theme md-list-item &gt; .md-avatar-icon {  background-color: &#x27;{{foreground-3}}&#x27;;  color: &#x27;{{background-color}}&#x27;; }md-list.md-THEME_NAME-theme md-list-item &gt; md-icon {  color: &#x27;{{foreground-2}}&#x27;; }  md-list.md-THEME_NAME-theme md-list-item &gt; md-icon.md-highlight {    color: &#x27;{{primary-color}}&#x27;; }    md-list.md-THEME_NAME-theme md-list-item &gt; md-icon.md-highlight.md-accent {      color: &#x27;{{accent-color}}&#x27;; }md-menu-content.md-THEME_NAME-theme {  background-color: &#x27;{{background-color}}&#x27;; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: &#x27;{{foreground-4}}&#x27;; }md-menu-bar.md-THEME_NAME-theme &gt; button.md-button {  color: &#x27;{{foreground-2}}&#x27;;  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open &gt; button, md-menu-bar.md-THEME_NAME-theme md-menu &gt; button:focus {  outline: none;  background: &#x27;{{background-200}}&#x27;; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover &gt; button {  background-color: &#x27;{{ background-500-0.2}}&#x27;; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu &gt; .md-button:after {  color: &#x27;{{foreground-2}}&#x27;; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open &gt; .md-button {  background-color: &#x27;{{ background-500-0.2}}&#x27;; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: &#x27;{{background-color}}&#x27;;  color: &#x27;{{foreground-1}}&#x27;; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: &#x27;{{primary-color}}&#x27;;    color: &#x27;{{primary-contrast}}&#x27;; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: &#x27;{{primary-contrast}}&#x27;; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: &#x27;{{primary-color}}&#x27;;    border-bottom-color: &#x27;{{primary-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: &#x27;{{primary-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: &#x27;{{primary-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: &#x27;{{primary-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: &#x27;{{warn-color}}&#x27;;    border-bottom-color: &#x27;{{warn-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: &#x27;{{warn-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: &#x27;{{warn-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: &#x27;{{warn-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: &#x27;{{accent-color}}&#x27;;    border-bottom-color: &#x27;{{accent-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: &#x27;{{accent-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: &#x27;{{accent-color}}&#x27;; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: &#x27;{{accent-color}}&#x27;; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: &#x27;{{primary-100}}&#x27;; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: &#x27;{{primary-color}}&#x27;; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: &#x27;{{warn-100}}&#x27;; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: &#x27;{{warn-color}}&#x27;; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: &#x27;{{accent-100}}&#x27;; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: &#x27;{{accent-color}}&#x27;; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: &#x27;{{warn-100}}&#x27;; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\&quot;{{warn-100}}\&quot; 0%, \&quot;{{warn-100}}\&quot; 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: &#x27;{{accent-100}}&#x27;; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\&quot;{{accent-100}}\&quot; 0%, \&quot;{{accent-100}}\&quot; 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: &#x27;{{foreground-2}}&#x27;; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: &#x27;{{accent-color-0.87}}&#x27;; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: &#x27;{{accent-color-0.87}}&#x27;; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: &#x27;{{accent-color-0.87}}&#x27;; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: &#x27;{{accent-600}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: &#x27;{{primary-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: &#x27;{{primary-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: &#x27;{{primary-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: &#x27;{{primary-600}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: &#x27;{{warn-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: &#x27;{{warn-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: &#x27;{{warn-color-0.87}}&#x27;; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: &#x27;{{warn-600}}&#x27;; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: &#x27;{{foreground-3}}&#x27;; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: &#x27;{{foreground-3}}&#x27;; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: &#x27;{{foreground-3}}&#x27;; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: &#x27;{{accent-color-0.26}}&#x27;; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: &#x27;{{primary-color-0.26}}&#x27;; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: &#x27;{{warn-color-0.26}}&#x27;; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: &#x27;{{accent-color-0.26}}&#x27;; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: &#x27;{{primary-color-0.26}}&#x27;; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: &#x27;{{warn-color-0.26}}&#x27;; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \&quot;{{foreground-3}}\&quot; 0%, \&quot;{{foreground-3}}\&quot; 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \&quot;{{foreground-3}}\&quot; 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: &#x27;{{foreground-4}}&#x27;; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: &#x27;{{foreground-3}}&#x27;; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: &#x27;{{warn-A700}}&#x27; !important;  border-bottom-color: &#x27;{{warn-A700}}&#x27; !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: &#x27;{{primary-color}}&#x27;;  color: &#x27;{{ foreground-1 }}&#x27;; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: &#x27;{{ foreground-1 }}&#x27;; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: &#x27;{{accent-color}}&#x27;; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: &#x27;{{warn-color}}&#x27;; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: &#x27;{{foreground-3}}&#x27;; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: &#x27;{{foreground-3}}&#x27;; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: &#x27;{{foreground-3}}&#x27;; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: &#x27;{{foreground-2}}&#x27;; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: &#x27;{{foreground-1}}&#x27;; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: &#x27;{{primary-500}}&#x27;; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: &#x27;{{primary-600}}&#x27;; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: &#x27;{{accent-500}}&#x27;; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: &#x27;{{accent-600}}&#x27;; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: &#x27;{{background-200}}&#x27;; }md-sidenav.md-THEME_NAME-theme {  background-color: &#x27;{{background-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-track {  background-color: &#x27;{{foreground-3}}&#x27;; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: &#x27;{{foreground-4}}&#x27;; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: &#x27;{{foreground-2}}&#x27;; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: &#x27;{{accent-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: &#x27;{{background-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: &#x27;{{background-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: &#x27;{{accent-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: &#x27;{{accent-color}}&#x27;;  background-color: &#x27;{{accent-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: &#x27;{{accent-color}}&#x27;; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: &#x27;{{accent-color}}&#x27;; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: &#x27;{{accent-contrast}}&#x27;; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: &#x27;{{warn-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: &#x27;{{warn-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: &#x27;{{warn-color}}&#x27;;  background-color: &#x27;{{warn-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: &#x27;{{warn-color}}&#x27;; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: &#x27;{{warn-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: &#x27;{{warn-contrast}}&#x27;; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: &#x27;{{primary-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: &#x27;{{primary-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: &#x27;{{primary-color}}&#x27;;  background-color: &#x27;{{primary-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: &#x27;{{primary-color}}&#x27;; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: &#x27;{{primary-color}}&#x27;; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: &#x27;{{primary-contrast}}&#x27;; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: &#x27;{{foreground-3}}&#x27;; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: &#x27;{{foreground-3}}&#x27;; }.md-subheader.md-THEME_NAME-theme {  color: &#x27;{{ foreground-2-0.23 }}&#x27;;  background-color: &#x27;{{background-color}}&#x27;; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: &#x27;{{primary-color}}&#x27;; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: &#x27;{{accent-color}}&#x27;; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: &#x27;{{warn-color}}&#x27;; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: &#x27;{{foreground-4}}&#x27;; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: &#x27;{{primary-color}}&#x27;; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: &#x27;{{accent-color}}&#x27;;  background: &#x27;{{accent-color}}&#x27;; }md-tabs.md-THEME_NAME-theme .md-tab {  color: &#x27;{{foreground-2}}&#x27;; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: &#x27;{{foreground-3}}&#x27;; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: &#x27;{{primary-color}}&#x27;; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: &#x27;{{primary-color-0.1}}&#x27;; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: &#x27;{{accent-100}}&#x27;; }md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper {  background-color: &#x27;{{accent-color}}&#x27;; }  md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{accent-100}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{accent-contrast}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{accent-contrast-0.1}}&#x27;; }  md-tabs.md-THEME_NAME-theme.md-accent &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-ink-bar {    color: &#x27;{{primary-600-1}}&#x27;;    background: &#x27;{{primary-600-1}}&#x27;; }md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper {  background-color: &#x27;{{primary-color}}&#x27;; }  md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{primary-100}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{primary-contrast}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-primary &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{primary-contrast-0.1}}&#x27;; }md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper {  background-color: &#x27;{{warn-color}}&#x27;; }  md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{warn-100}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{warn-contrast}}&#x27;; }    md-tabs.md-THEME_NAME-theme.md-warn &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{warn-contrast-0.1}}&#x27;; }md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper {  background-color: &#x27;{{primary-color}}&#x27;; }  md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{primary-100}}&#x27;; }    md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{primary-contrast}}&#x27;; }    md-toolbar &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{primary-contrast-0.1}}&#x27;; }md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper {  background-color: &#x27;{{accent-color}}&#x27;; }  md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{accent-100}}&#x27;; }    md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{accent-contrast}}&#x27;; }    md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{accent-contrast-0.1}}&#x27;; }  md-toolbar.md-accent &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-ink-bar {    color: &#x27;{{primary-600-1}}&#x27;;    background: &#x27;{{primary-600-1}}&#x27;; }md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper {  background-color: &#x27;{{warn-color}}&#x27;; }  md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]) {    color: &#x27;{{warn-100}}&#x27;; }    md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active, md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused md-icon {      color: &#x27;{{warn-contrast}}&#x27;; }    md-toolbar.md-warn &gt; md-tabs.md-THEME_NAME-theme &gt; md-tabs-wrapper &gt; md-tabs-canvas &gt; md-pagination-wrapper &gt; md-tab-item:not([disabled]).md-focused {      background: &#x27;{{warn-contrast-0.1}}&#x27;; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: &#x27;{{background-50}}&#x27;; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: &#x27;{{background-50}}&#x27;; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: &#x27;{{primary-A200}}&#x27;; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: &#x27;{{accent-A200}}&#x27;; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: &#x27;{{warn-A200}}&#x27;; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: &#x27;{{background-500}}&#x27;; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: &#x27;{{background-50}}&#x27;; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: &#x27;{{background-500}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: &#x27;{{accent-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: &#x27;{{accent-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: &#x27;{{accent-color-0.5}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: &#x27;{{accent-color-0.26}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: &#x27;{{primary-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: &#x27;{{primary-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: &#x27;{{primary-color-0.5}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: &#x27;{{primary-color-0.26}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: &#x27;{{warn-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: &#x27;{{warn-color}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: &#x27;{{warn-color-0.5}}&#x27;; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: &#x27;{{warn-color-0.26}}&#x27;; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: &#x27;{{background-400}}&#x27;; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: &#x27;{{foreground-4}}&#x27;; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: &#x27;{{primary-color}}&#x27;;  color: &#x27;{{primary-contrast}}&#x27;; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: &#x27;{{primary-contrast}}&#x27;; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: &#x27;{{primary-contrast}}&#x27;; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: &#x27;{{accent-color}}&#x27;;    color: &#x27;{{accent-contrast}}&#x27;; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: &#x27;{{warn-color}}&#x27;;    color: &#x27;{{warn-contrast}}&#x27;; }md-tooltip.md-THEME_NAME-theme {  color: &#x27;{{background-A100}}&#x27;; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: &#x27;{{foreground-2}}&#x27;; }&quot;); 
})();


ng.material.core = angular.module(&quot;material.core&quot;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
